<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스케줄링·RR·MLQ·MLFQ·기아현상·에이징</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap');
        body{font-family:'Noto Sans KR',sans-serif;background-color:#f5f5f4;color:#1f2937}
        .chart-container{position:relative;width:100%;max-width:600px;margin-left:auto;margin-right:auto;height:350px;max-height:400px}
        .nav-item.active{border-bottom:2px solid #4f46e5;color:#4f46e5;font-weight:700}
        .tech-block{transition:all .3s ease;cursor:pointer}.tech-block:hover{transform:translateY(-2px);box-shadow:0 4px 6px -1px rgba(0,0,0,.1)}
        .tech-block.selected{ring:2px;ring-color:#4f46e5;background-color:#eef2ff;border-color:#4f46e5}
        .no-scrollbar::-webkit-scrollbar{display:none}.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}
        #chat-sidebar{transition:transform .3s ease-in-out}#chat-sidebar.closed{transform:translateX(100%)}#chat-sidebar.open{transform:translateX(0)}
        .def-box{background:linear-gradient(135deg,#eef2ff 0%,#e0e7ff 100%);border-left:4px solid #4f46e5;border-radius:8px;padding:1.25rem;margin-bottom:1rem}
        .def-box p{color:#312e81;font-weight:500;margin:0;line-height:1.8}
        .insight-box{background-color:#fffbeb;border:1px solid #fde68a;border-radius:8px;padding:1rem;margin:1rem 0}.insight-box::before{content:'💡';margin-right:.5rem}
        .textbook-content h3{font-size:1.25rem;font-weight:700;color:#1e3a8a;margin-top:1.5rem;margin-bottom:.75rem;border-left:4px solid #4f46e5;padding-left:.75rem}
        .textbook-content h4{font-size:1.1rem;font-weight:600;color:#374151;margin-top:1rem;margin-bottom:.5rem}
        .textbook-content p{margin-bottom:1rem;line-height:1.8;color:#4b5563}
        .textbook-content ul{list-style-type:disc;padding-left:1.5rem;margin-bottom:1rem;color:#4b5563}
        .textbook-content li{margin-bottom:.5rem;line-height:1.7}
        .textbook-content table{width:100%;border-collapse:collapse;margin-bottom:1.5rem;font-size:.95rem}
        .textbook-content th,.textbook-content td{border:1px solid #e5e7eb;padding:.75rem;text-align:left}
        .textbook-content th{background-color:#f9fafb;font-weight:600;color:#1f2937}
        .textbook-content .highlight{background-color:#eef2ff;color:#4338ca;font-weight:600;padding:0 4px;border-radius:4px}
        .textbook-content pre{background-color:#f8fafc;border:1px solid #e2e8f0;border-radius:8px;padding:1rem;overflow-x:auto;margin-bottom:1rem;font-size:.85rem;line-height:1.6}
        .textbook-content code{font-family:'Courier New',monospace}
        .chat-msg{border-radius:12px;padding:10px 14px;margin-bottom:10px;max-width:85%;font-size:.95rem}
        .chat-msg.user{background-color:#4f46e5;color:white;align-self:flex-end;margin-left:auto}
        .chat-msg.ai{background-color:#f3f4f6;color:#1f2937;align-self:flex-start;border:1px solid #e5e7eb}
        .typing-indicator span{display:inline-block;width:6px;height:6px;background-color:#4f46e5;border-radius:50%;animation:typing 1.4s infinite ease-in-out both;margin:0 2px}
        .typing-indicator span:nth-child(1){animation-delay:-.32s}.typing-indicator span:nth-child(2){animation-delay:-.16s}
        @keyframes typing{0%,80%,100%{transform:scale(0)}40%{transform:scale(1)}}
        @keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
        .animate-fade-in{animation:fadeIn .4s ease-out forwards}
        .strategy-card{cursor:pointer;transition:all .3s ease}.strategy-card:hover{transform:translateY(-2px);box-shadow:0 4px 6px -1px rgba(0,0,0,.1)}
    </style>
</head>
<body class="bg-stone-100 min-h-screen flex flex-col overflow-x-hidden">
    <header class="bg-white shadow-sm sticky top-0 z-40">
        <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center pt-3 pb-1">
                <div class="flex flex-col justify-center min-w-0">
                    <span class="text-[10px] sm:text-xs text-indigo-600 font-bold uppercase tracking-wider leading-tight">KPC 정보관리기술사 ZIP-UP 심화반</span>
                    <div class="flex items-center gap-2">
                        <span class="text-lg sm:text-xl font-bold text-gray-900 tracking-tight truncate">스케줄링·RR·MLQ·MLFQ·에이징</span>
                        <span class="text-[10px] sm:text-xs bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded-full font-bold flex-shrink-0">2026</span>
                    </div>
                </div>
            </div>
            <nav class="flex space-x-1 sm:space-x-4 overflow-x-auto no-scrollbar pb-1 items-center">
                <button onclick="navTo('overview')" id="nav-overview" class="nav-item active px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">개요 및 개념</button>
                <button onclick="navTo('comparison')" id="nav-comparison" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">선점형 vs 비선점형</button>
                <button onclick="navTo('algorithms')" id="nav-algorithms" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">RR·MLQ·MLFQ</button>
                <button onclick="navTo('starvation')" id="nav-starvation" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">기아현상·에이징</button>
                <button onclick="navTo('textbook')" id="nav-textbook" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">원문 학습</button>
                <button onclick="navTo('script')" id="nav-script" class="nav-item hidden px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap text-amber-700">🎬 강의 스크립트</button>
                <button onclick="navTo('quiz')" id="nav-quiz" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">퀴즈 &amp; 암기</button>
                <span class="w-px h-4 bg-gray-300 flex-shrink-0"></span>
                <button onclick="toggleSettings()" class="flex items-center gap-1 px-2.5 py-1 rounded-full text-xs font-medium text-indigo-600 hover:bg-indigo-50 border border-indigo-200 hover:border-indigo-400 transition-all whitespace-nowrap flex-shrink-0" title="API Key 설정">🔑 API</button>
            </nav>
        </div>
    </header>
    <main class="flex-grow max-w-5xl w-full mx-auto px-4 sm:px-6 lg:px-8 py-8 space-y-12 pb-24">

    <section id="overview">
        <div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 animate-fade-in">
            <h2 class="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2">📋 개요 및 개념</h2>

            <!-- 정의 박스 -->
            <div class="def-box mb-4">
                <p><strong>CPU 스케줄링(CPU Scheduling)</strong>이란 다중 프로그래밍 환경에서 준비 상태(Ready State)의 여러 프로세스 중 어떤 프로세스에게 CPU를 할당할지 결정하는 운영체제 커널의 핵심 기능이다.</p>
            </div>
            <div class="def-box mb-4">
                <p><strong>선점형 스케줄링(Preemptive Scheduling)</strong>이란 타이머 인터럽트로 실행 중인 프로세스의 CPU를 강제 회수할 수 있는 스케줄링 방식이다. (대표: RR, SRT, MLFQ)</p>
            </div>
            <div class="def-box mb-6">
                <p><strong>비선점형 스케줄링(Non-Preemptive Scheduling)</strong>이란 프로세스가 자발적으로 CPU를 반납할 때까지 점유를 보장하는 스케줄링 방식이다. (대표: FCFS, SJF, HRN)</p>
            </div>

            <!-- 개념 해설 -->
            <p class="text-gray-600 leading-relaxed mb-6">스케줄링 정책은 <strong>"CPU를 강제로 회수할 수 있느냐"</strong>의 여부에 따라 선점형과 비선점형으로 대별됩니다. 이 기본 분류 위에서 RR→MLQ→MLFQ로 알고리즘이 진화하였으며, 진화 과정에서 발생한 기아(Starvation) 문제를 에이징(Aging)과 Priority Boosting으로 해결합니다. 이 세 소문제는 <strong>분류(기초) → 진화(알고리즘) → 보완(공정성)</strong>의 논리적 연결 구조를 갖습니다.</p>

            <div class="insight-box mb-8">
                <span class="text-sm text-amber-800">스케줄링의 궁극적 목표는 <strong>처리량(Throughput) 극대화</strong>와 <strong>응답 시간(Response Time) 최소화</strong>의 균형이며, MLFQ + 에이징이 현대 OS에서 이 균형을 달성하는 표준 메커니즘입니다.</span>
            </div>

            <!-- 소문제 3카드 그리드 -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                <div class="bg-blue-50 rounded-lg p-5 border border-blue-200">
                    <div class="text-blue-600 font-bold text-sm mb-1">소문제 1</div>
                    <h4 class="font-bold text-gray-900 mb-2">선점형 vs 비선점형</h4>
                    <p class="text-sm text-gray-600">스케줄링의 두 가지 큰 줄기. CPU 강제 회수 여부에 따른 기초 분류와 10대 비교 기준.</p>
                    <div class="mt-3 text-xs text-blue-700 font-medium">🔑 비교 핵심: "회응공실적대"</div>
                </div>
                <div class="bg-green-50 rounded-lg p-5 border border-green-200">
                    <div class="text-green-600 font-bold text-sm mb-1">소문제 2</div>
                    <h4 class="font-bold text-gray-900 mb-2">RR·MLQ·MLFQ 알고리즘</h4>
                    <p class="text-sm text-gray-600">공정성→분류→적응적 분류로의 진화. MLFQ 5대 규칙과 동적 큐 이동.</p>
                    <div class="mt-3 text-xs text-green-700 font-medium">🔑 MLFQ 5규칙: "우동최하유"</div>
                </div>
                <div class="bg-purple-50 rounded-lg p-5 border border-purple-200">
                    <div class="text-purple-600 font-bold text-sm mb-1">소문제 3</div>
                    <h4 class="font-bold text-gray-900 mb-2">기아현상·에이징</h4>
                    <p class="text-sm text-gray-600">스케줄링 진화의 부작용(기아)과 해결책. HRN, Priority Boosting.</p>
                    <div class="mt-3 text-xs text-purple-700 font-medium">🔑 기아 해결: "에부적"</div>
                </div>
            </div>

            <!-- 진화 흐름 시각화 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">📈 스케줄링 알고리즘 진화 흐름</h3>
            <div class="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-xl p-6 border border-indigo-200 mb-6">
                <div class="flex flex-col sm:flex-row items-center justify-between gap-3 text-center">
                    <div class="bg-white rounded-lg px-4 py-3 shadow-sm border flex-1">
                        <div class="text-xs text-gray-500 mb-1">단순 순서</div>
                        <div class="font-bold text-gray-800">FCFS</div>
                    </div>
                    <div class="text-indigo-400 font-bold text-lg hidden sm:block">→</div>
                    <div class="text-indigo-400 font-bold text-lg sm:hidden">↓</div>
                    <div class="bg-white rounded-lg px-4 py-3 shadow-sm border flex-1">
                        <div class="text-xs text-gray-500 mb-1">최적화</div>
                        <div class="font-bold text-gray-800">SJF</div>
                    </div>
                    <div class="text-indigo-400 font-bold text-lg hidden sm:block">→</div>
                    <div class="text-indigo-400 font-bold text-lg sm:hidden">↓</div>
                    <div class="bg-blue-100 rounded-lg px-4 py-3 shadow-sm border border-blue-300 flex-1">
                        <div class="text-xs text-blue-600 mb-1">공정성</div>
                        <div class="font-bold text-blue-800">RR</div>
                    </div>
                    <div class="text-indigo-400 font-bold text-lg hidden sm:block">→</div>
                    <div class="text-indigo-400 font-bold text-lg sm:hidden">↓</div>
                    <div class="bg-green-100 rounded-lg px-4 py-3 shadow-sm border border-green-300 flex-1">
                        <div class="text-xs text-green-600 mb-1">분류</div>
                        <div class="font-bold text-green-800">MLQ</div>
                    </div>
                    <div class="text-indigo-400 font-bold text-lg hidden sm:block">→</div>
                    <div class="text-indigo-400 font-bold text-lg sm:hidden">↓</div>
                    <div class="bg-purple-100 rounded-lg px-4 py-3 shadow-sm border border-purple-300 flex-1">
                        <div class="text-xs text-purple-600 mb-1">적응적 분류</div>
                        <div class="font-bold text-purple-800">MLFQ</div>
                    </div>
                </div>
                <p class="text-xs text-center text-gray-500 mt-4">* 핵심 변화: 프로세스의 성격(CPU-Bound vs I/O-Bound)을 어떻게 구분하고 차별적으로 처리할 것인가</p>
            </div>

            <!-- 스케줄링 목표 차트 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">📊 스케줄링 5대 목표 달성 비교</h3>
            <div class="chart-container mb-2"><canvas id="overviewChart"></canvas></div>
            <p class="text-xs text-center text-gray-400 mb-2">* 점수는 상대적 비교를 위한 예시 값입니다.</p>
        </div>
    </section>
    <script>
    new Chart(document.getElementById('overviewChart'),{type:'radar',data:{labels:['CPU 이용률','처리량','응답 시간','공정성','구현 용이성'],datasets:[{label:'RR',data:[7,6,8,9,8],borderColor:'#3b82f6',backgroundColor:'rgba(59,130,246,0.1)',pointBackgroundColor:'#3b82f6'},{label:'MLQ',data:[8,8,7,5,6],borderColor:'#22c55e',backgroundColor:'rgba(34,197,94,0.1)',pointBackgroundColor:'#22c55e'},{label:'MLFQ',data:[9,9,9,8,4],borderColor:'#a855f7',backgroundColor:'rgba(168,85,247,0.1)',pointBackgroundColor:'#a855f7'}]},options:{responsive:true,maintainAspectRatio:false,scales:{r:{beginAtZero:true,max:10,ticks:{stepSize:2,font:{size:10}},pointLabels:{font:{size:11}}}},plugins:{legend:{position:'bottom',labels:{font:{size:11}}}}}});
    </script>

    <section id="comparison" class="hidden">
        <div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 animate-fade-in">
            <h2 class="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2">⚖️ 선점형 vs 비선점형 스케줄링</h2>

            <!-- 핵심 차이 카드 -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <div class="bg-blue-50 rounded-xl p-6 border-l-4 border-blue-500">
                    <h3 class="font-bold text-blue-800 text-lg mb-3">🔄 선점형 (Preemptive)</h3>
                    <p class="text-sm text-gray-700 mb-3">운영체제가 <strong>타이머 인터럽트</strong>를 기반으로 CPU를 <strong>강제 회수</strong>할 수 있는 방식.</p>
                    <div class="space-y-2">
                        <div class="flex items-start gap-2"><span class="text-green-500 mt-0.5">✅</span><span class="text-sm text-gray-600">응답 시간이 짧아 대화형/실시간 시스템에 적합</span></div>
                        <div class="flex items-start gap-2"><span class="text-green-500 mt-0.5">✅</span><span class="text-sm text-gray-600">모든 프로세스에 CPU 배분 → 높은 공정성</span></div>
                        <div class="flex items-start gap-2"><span class="text-red-500 mt-0.5">⚠️</span><span class="text-sm text-gray-600">빈번한 문맥 교환 오버헤드</span></div>
                        <div class="flex items-start gap-2"><span class="text-red-500 mt-0.5">⚠️</span><span class="text-sm text-gray-600">Race Condition 대비 동기화 필수</span></div>
                    </div>
                    <div class="mt-4 bg-white rounded-lg p-3 border">
                        <span class="text-xs font-bold text-blue-700">대표 알고리즘:</span>
                        <span class="text-xs text-gray-600"> RR, SRT, 선점형 Priority, MLFQ</span>
                    </div>
                </div>
                <div class="bg-amber-50 rounded-xl p-6 border-l-4 border-amber-500">
                    <h3 class="font-bold text-amber-800 text-lg mb-3">⏳ 비선점형 (Non-Preemptive)</h3>
                    <p class="text-sm text-gray-700 mb-3">프로세스가 <strong>자발적으로 반납</strong>(I/O 요청 또는 종료)할 때까지 CPU 점유를 보장하는 방식.</p>
                    <div class="space-y-2">
                        <div class="flex items-start gap-2"><span class="text-green-500 mt-0.5">✅</span><span class="text-sm text-gray-600">문맥 교환 비용 낮아 배치 처리에 유리</span></div>
                        <div class="flex items-start gap-2"><span class="text-green-500 mt-0.5">✅</span><span class="text-sm text-gray-600">구현이 단순 (인터럽트 처리 불필요)</span></div>
                        <div class="flex items-start gap-2"><span class="text-red-500 mt-0.5">⚠️</span><span class="text-sm text-gray-600">호위 효과(Convoy Effect) 발생</span></div>
                        <div class="flex items-start gap-2"><span class="text-red-500 mt-0.5">⚠️</span><span class="text-sm text-gray-600">실시간 처리 불가, 공정성 낮음</span></div>
                    </div>
                    <div class="mt-4 bg-white rounded-lg p-3 border">
                        <span class="text-xs font-bold text-amber-700">대표 알고리즘:</span>
                        <span class="text-xs text-gray-600"> FCFS, SJF, 비선점형 Priority, HRN</span>
                    </div>
                </div>
            </div>

            <!-- 10대 비교표 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">📊 체계적 비교표 (10대 기준)</h3>
            <div class="overflow-x-auto mb-8">
                <table class="w-full border-collapse text-sm">
                    <thead>
                        <tr class="bg-gray-50">
                            <th class="border border-gray-200 px-4 py-3 text-left font-bold text-gray-900">비교 기준</th>
                            <th class="border border-gray-200 px-4 py-3 text-left font-bold text-blue-800">선점형(Preemptive)</th>
                            <th class="border border-gray-200 px-4 py-3 text-left font-bold text-amber-800">비선점형(Non-Preemptive)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">CPU 회수 방식</td><td class="border border-gray-200 px-4 py-2">타이머 인터럽트에 의한 강제 회수</td><td class="border border-gray-200 px-4 py-2">프로세스 자발적 반납(I/O, 종료)</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">문맥 교환 빈도</td><td class="border border-gray-200 px-4 py-2">높음 (오버헤드 발생)</td><td class="border border-gray-200 px-4 py-2">낮음 (오버헤드 적음)</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">응답 시간</td><td class="border border-gray-200 px-4 py-2">짧음 (대화형 시스템에 유리)</td><td class="border border-gray-200 px-4 py-2">길어질 수 있음 (Convoy Effect)</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">처리량(Throughput)</td><td class="border border-gray-200 px-4 py-2">오버헤드로 인해 다소 감소</td><td class="border border-gray-200 px-4 py-2">문맥 교환 적어 배치 처리에 유리</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">공정성</td><td class="border border-gray-200 px-4 py-2">높음 (모든 프로세스에 CPU 배분)</td><td class="border border-gray-200 px-4 py-2">낮음 (긴 프로세스에 유리)</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">동기화 필요성</td><td class="border border-gray-200 px-4 py-2">높음 (Race Condition 대비 필수)</td><td class="border border-gray-200 px-4 py-2">낮음 (실행 중 중단 없음)</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">실시간 지원</td><td class="border border-gray-200 px-4 py-2">가능 (긴급 태스크 즉시 처리)</td><td class="border border-gray-200 px-4 py-2">불가 (실행 완료까지 대기)</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">구현 복잡도</td><td class="border border-gray-200 px-4 py-2">높음 (인터럽트, 동기화 처리)</td><td class="border border-gray-200 px-4 py-2">낮음 (단순한 큐 관리)</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">적합 환경</td><td class="border border-gray-200 px-4 py-2">대화형, 실시간, 클라우드</td><td class="border border-gray-200 px-4 py-2">배치 처리, 단순 임베디드</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium bg-indigo-50">대표 알고리즘</td><td class="border border-gray-200 px-4 py-2">RR, SRT, MLFQ</td><td class="border border-gray-200 px-4 py-2">FCFS, SJF, HRN</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- 암기 팁 -->
            <div class="bg-indigo-50 rounded-xl p-5 border border-indigo-200">
                <h4 class="font-bold text-indigo-800 mb-2">🔑 비교 핵심 기준 두문자어</h4>
                <p class="text-sm text-gray-700 mb-2">10개 기준 전체: <span class="highlight">회문응처공동실구적대</span> → 핵심 6개로 축약: <span class="highlight">회응공실적대</span></p>
                <p class="text-xs text-gray-500">(회수방식 - 응답시간 - 공정성 - 실시간지원 - 적합환경 - 대표알고리즘)</p>
            </div>
        </div>
    </section>

    <section id="algorithms" class="hidden">
        <div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 animate-fade-in">
            <h2 class="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2">🔧 RR·MLQ·MLFQ 알고리즘</h2>

            <!-- tech-block 3개 -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div id="block-rr" class="tech-block selected bg-white rounded-lg p-5 border-2 border-blue-300 shadow-sm" onclick="updateAlgoDetail('rr')">
                    <div class="text-blue-600 font-bold mb-1">🔄 RR</div>
                    <div class="text-sm font-bold text-gray-900">Round Robin</div>
                    <p class="text-xs text-gray-500 mt-1">동일 TQ 순환 할당, 공정성 보장</p>
                </div>
                <div id="block-mlq" class="tech-block bg-white rounded-lg p-5 border-2 border-gray-200 shadow-sm" onclick="updateAlgoDetail('mlq')">
                    <div class="text-green-600 font-bold mb-1">📊 MLQ</div>
                    <div class="text-sm font-bold text-gray-900">Multi-Level Queue</div>
                    <p class="text-xs text-gray-500 mt-1">다수 고정 큐, 유형별 영구 배정</p>
                </div>
                <div id="block-mlfq" class="tech-block bg-white rounded-lg p-5 border-2 border-gray-200 shadow-sm" onclick="updateAlgoDetail('mlfq')">
                    <div class="text-purple-600 font-bold mb-1">⚡ MLFQ</div>
                    <div class="text-sm font-bold text-gray-900">Multi-Level Feedback Queue</div>
                    <p class="text-xs text-gray-500 mt-1">피드백 기반 동적 큐 이동</p>
                </div>
            </div>

            <!-- 상세 설명 패널 -->
            <div id="algo-detail-content" class="mb-8">
                <div class="p-5 rounded-lg border-l-4 border-blue-500 bg-blue-50 animate-fade-in">
                    <h3 class="text-lg font-bold text-gray-900 mb-3">RR (Round Robin)</h3>
                    <h4 class="font-bold text-blue-800 mb-2">동작: 동일 Time Quantum으로 순환 할당</h4>
                    <p class="text-sm text-gray-700 mb-2">모든 프로세스에 동일한 시간(q)을 부여, 큐를 순환하며 CPU 할당. q 만료 시 Ready Queue 맨 뒤로 이동.</p>
                    <p class="text-sm text-gray-700 mb-2"><strong>최적 q:</strong> CPU Burst의 80%가 q 이내에 완료 (일반적 10~100ms)</p>
                    <p class="text-sm text-gray-700"><strong>장점:</strong> 공정성 보장, 기아 없음 / <strong>단점:</strong> CPU-Bound vs I/O-Bound 구분 불가</p>
                </div>
            </div>

            <!-- RR 동작 예시 테이블 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">📋 RR 동작 예시 (Time Quantum = 4ms)</h3>
            <div class="overflow-x-auto mb-6">
                <table class="w-full border-collapse text-sm">
                    <thead><tr class="bg-gray-50">
                        <th class="border border-gray-200 px-4 py-2 font-bold">프로세스</th>
                        <th class="border border-gray-200 px-4 py-2 font-bold">도착시간</th>
                        <th class="border border-gray-200 px-4 py-2 font-bold">실행시간(Burst)</th>
                        <th class="border border-gray-200 px-4 py-2 font-bold">실행 순서</th>
                    </tr></thead>
                    <tbody>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium">P1</td><td class="border border-gray-200 px-4 py-2">0</td><td class="border border-gray-200 px-4 py-2">10ms</td><td class="border border-gray-200 px-4 py-2">0~4 → 8~12 → 16~18</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium">P2</td><td class="border border-gray-200 px-4 py-2">0</td><td class="border border-gray-200 px-4 py-2">4ms</td><td class="border border-gray-200 px-4 py-2">4~8 (완료)</td></tr>
                        <tr><td class="border border-gray-200 px-4 py-2 font-medium">P3</td><td class="border border-gray-200 px-4 py-2">0</td><td class="border border-gray-200 px-4 py-2">6ms</td><td class="border border-gray-200 px-4 py-2">12~16 → 18~20</td></tr>
                    </tbody>
                </table>
                <p class="text-xs text-gray-500 mt-2">평균 대기시간 = (8+4+12)/3 = 8ms</p>
            </div>

            <!-- TQ 영향 -->
            <div class="bg-blue-50 rounded-lg p-5 border border-blue-200 mb-8">
                <h4 class="font-bold text-blue-800 mb-3">⏱️ Time Quantum의 영향</h4>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                    <div class="bg-white rounded-lg p-3 border text-center">
                        <div class="text-sm font-bold text-gray-800">q → ∞</div>
                        <div class="text-xs text-gray-500 mt-1">FCFS와 동일<br>(문맥 교환 없음)</div>
                    </div>
                    <div class="bg-white rounded-lg p-3 border text-center border-blue-300">
                        <div class="text-sm font-bold text-blue-700">최적 q</div>
                        <div class="text-xs text-gray-500 mt-1">CPU Burst 80% 완료<br>(10~100ms)</div>
                    </div>
                    <div class="bg-white rounded-lg p-3 border text-center">
                        <div class="text-sm font-bold text-gray-800">q → 0</div>
                        <div class="text-xs text-gray-500 mt-1">Processor Sharing<br>(오버헤드 극대화)</div>
                    </div>
                </div>
            </div>

            <!-- MLFQ 큐 구조 시각화 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">🏗️ MLFQ 큐 구조도</h3>
            <div class="bg-gradient-to-b from-purple-50 to-indigo-50 rounded-xl p-6 border border-purple-200 mb-6">
                <div class="max-w-lg mx-auto space-y-0">
                    <!-- Q0 -->
                    <div class="bg-purple-100 border-2 border-purple-400 rounded-t-xl p-4 relative">
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="font-bold text-purple-800">Q0</span>
                                <span class="text-sm text-purple-700 ml-2">최우선, q=8ms, RR</span>
                            </div>
                            <span class="text-xs bg-purple-200 text-purple-800 px-2 py-1 rounded-full">I/O-Bound 유지</span>
                        </div>
                        <div class="absolute -right-20 top-1/2 -translate-y-1/2 text-xs text-purple-600 font-medium hidden md:block">← 신규 프로세스 진입</div>
                    </div>
                    <!-- 화살표 -->
                    <div class="flex justify-center py-1">
                        <div class="text-center">
                            <div class="text-purple-500 font-bold">↓</div>
                            <div class="text-xs text-gray-500">TQ 만료 시</div>
                        </div>
                    </div>
                    <!-- Q1 -->
                    <div class="bg-indigo-100 border-2 border-indigo-400 p-4">
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="font-bold text-indigo-800">Q1</span>
                                <span class="text-sm text-indigo-700 ml-2">중간, q=16ms, RR</span>
                            </div>
                            <span class="text-xs bg-indigo-200 text-indigo-800 px-2 py-1 rounded-full">혼합형 프로세스</span>
                        </div>
                    </div>
                    <!-- 화살표 -->
                    <div class="flex justify-center py-1">
                        <div class="text-center">
                            <div class="text-indigo-500 font-bold">↓</div>
                            <div class="text-xs text-gray-500">TQ 만료 시</div>
                        </div>
                    </div>
                    <!-- Q2 -->
                    <div class="bg-blue-100 border-2 border-blue-400 rounded-b-xl p-4">
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="font-bold text-blue-800">Q2</span>
                                <span class="text-sm text-blue-700 ml-2">최하위, FCFS</span>
                            </div>
                            <span class="text-xs bg-blue-200 text-blue-800 px-2 py-1 rounded-full">CPU-Bound 프로세스</span>
                        </div>
                    </div>
                </div>
                <p class="text-xs text-center text-gray-500 mt-4">TQ 만료 → 하위 큐 이동 (CPU-Bound 판정) | I/O 요청 → 현재 큐 유지 (I/O-Bound 판정)</p>
            </div>

            <!-- MLFQ 5대 규칙 -->
            <div class="bg-purple-50 rounded-xl p-5 border border-purple-200 mb-8">
                <h4 class="font-bold text-purple-800 mb-3">📌 MLFQ 5대 규칙 — <span class="highlight">"우동최하유"</span> (Arpaci-Dusseau, OSTEP)</h4>
                <div class="space-y-2">
                    <div class="flex items-start gap-3"><span class="bg-purple-200 text-purple-800 text-xs font-bold px-2 py-1 rounded flex-shrink-0">1. 우</span><span class="text-sm text-gray-700">Priority(A) > Priority(B)이면 A를 실행 (<strong>우</strong>선순위 비교)</span></div>
                    <div class="flex items-start gap-3"><span class="bg-purple-200 text-purple-800 text-xs font-bold px-2 py-1 rounded flex-shrink-0">2. 동</span><span class="text-sm text-gray-700">Priority(A) = Priority(B)이면 RR로 실행 (<strong>동</strong>등시 RR)</span></div>
                    <div class="flex items-start gap-3"><span class="bg-purple-200 text-purple-800 text-xs font-bold px-2 py-1 rounded flex-shrink-0">3. 최</span><span class="text-sm text-gray-700">최초 진입 시 <strong>최</strong>상위 큐에 배치</span></div>
                    <div class="flex items-start gap-3"><span class="bg-purple-200 text-purple-800 text-xs font-bold px-2 py-1 rounded flex-shrink-0">4. 하</span><span class="text-sm text-gray-700">TQ 모두 사용 시 <strong>하</strong>위 큐로 이동 (CPU-Bound 판정)</span></div>
                    <div class="flex items-start gap-3"><span class="bg-purple-200 text-purple-800 text-xs font-bold px-2 py-1 rounded flex-shrink-0">5. 유</span><span class="text-sm text-gray-700">TQ 이내 I/O 요청 시 현재 큐 <strong>유</strong>지 (I/O-Bound 판정)</span></div>
                </div>
            </div>

            <!-- RR/MLQ/MLFQ 종합 비교표 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">📊 RR, MLQ, MLFQ 종합 비교</h3>
            <div class="overflow-x-auto mb-6">
                <table class="w-full border-collapse text-sm">
                    <thead><tr class="bg-gray-50">
                        <th class="border border-gray-200 px-3 py-2 font-bold">비교 기준</th>
                        <th class="border border-gray-200 px-3 py-2 font-bold text-blue-800">RR</th>
                        <th class="border border-gray-200 px-3 py-2 font-bold text-green-800">MLQ</th>
                        <th class="border border-gray-200 px-3 py-2 font-bold text-purple-800">MLFQ</th>
                    </tr></thead>
                    <tbody>
                        <tr><td class="border border-gray-200 px-3 py-2 font-medium">큐 구조</td><td class="border border-gray-200 px-3 py-2">단일 큐</td><td class="border border-gray-200 px-3 py-2">다수 고정 큐</td><td class="border border-gray-200 px-3 py-2">다수 피드백 큐</td></tr>
                        <tr><td class="border border-gray-200 px-3 py-2 font-medium">큐 간 이동</td><td class="border border-gray-200 px-3 py-2">해당 없음</td><td class="border border-gray-200 px-3 py-2">불가</td><td class="border border-gray-200 px-3 py-2 font-bold text-purple-700">가능 (핵심)</td></tr>
                        <tr><td class="border border-gray-200 px-3 py-2 font-medium">프로세스 분류</td><td class="border border-gray-200 px-3 py-2">미분류 (동일 취급)</td><td class="border border-gray-200 px-3 py-2">사전 분류 (고정)</td><td class="border border-gray-200 px-3 py-2">동적 분류 (적응적)</td></tr>
                        <tr><td class="border border-gray-200 px-3 py-2 font-medium">기아 발생</td><td class="border border-gray-200 px-3 py-2">없음</td><td class="border border-gray-200 px-3 py-2">하위 큐 기아 가능</td><td class="border border-gray-200 px-3 py-2">하위 큐 기아 가능 (에이징 필요)</td></tr>
                        <tr><td class="border border-gray-200 px-3 py-2 font-medium">적합 환경</td><td class="border border-gray-200 px-3 py-2">단순 Time-Sharing</td><td class="border border-gray-200 px-3 py-2">프로세스 유형 명확</td><td class="border border-gray-200 px-3 py-2">범용 (현대 OS 표준)</td></tr>
                        <tr><td class="border border-gray-200 px-3 py-2 font-medium">복잡도</td><td class="border border-gray-200 px-3 py-2">낮음</td><td class="border border-gray-200 px-3 py-2">중간</td><td class="border border-gray-200 px-3 py-2">높음</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="insight-box">
                <span class="text-sm text-amber-800">Fernando Corbató가 1962년 CTSS에서 MLFQ를 최초 구현하였으며, 이 업적으로 1990년 튜링상을 수상. 현대의 거의 모든 범용 OS가 MLFQ 기반으로 설계됩니다.</span>
            </div>
        </div>
    </section>

    <section id="starvation" class="hidden">
        <div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 animate-fade-in">
            <h2 class="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2">🚨 기아현상과 에이징 기법</h2>

            <!-- 기아현상 정의 -->
            <div class="def-box mb-6">
                <p><strong>기아현상(Starvation)</strong>이란 특정 프로세스가 자원 할당 정책의 불공정으로 인해 CPU를 무한히 대기하여 실행되지 못하는 현상이다. 교착상태(Deadlock)와 달리 자원의 순환 대기가 아닌 <strong>할당 우선순위의 편향</strong>이 원인이다.</p>
            </div>

            <!-- 기아 발생 3원인: "우짧하" -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">⚠️ 기아 발생 3대 원인 — <span class="highlight">"우짧하"</span></h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                <div class="bg-red-50 rounded-lg p-5 border border-red-200">
                    <div class="text-red-600 font-bold text-sm mb-2">1. 우선순위 선점</div>
                    <p class="text-sm text-gray-700">높은 우선순위 프로세스가 지속적으로 도착 → 낮은 우선순위 프로세스 영구 대기</p>
                    <div class="mt-2 text-xs text-red-600">MLQ, 고정 우선순위 스케줄링</div>
                </div>
                <div class="bg-orange-50 rounded-lg p-5 border border-orange-200">
                    <div class="text-orange-600 font-bold text-sm mb-2">2. 짧은 작업 연속</div>
                    <p class="text-sm text-gray-700">짧은 작업이 계속 도착하면 긴 작업이 무한 대기</p>
                    <div class="mt-2 text-xs text-orange-600">SJF, SRT 알고리즘</div>
                </div>
                <div class="bg-amber-50 rounded-lg p-5 border border-amber-200">
                    <div class="text-amber-600 font-bold text-sm mb-2">3. 하위 큐 고착</div>
                    <p class="text-sm text-gray-700">CPU-Bound 프로세스가 최하위 큐로 이동 후 상위 큐에 의해 지속 선점</p>
                    <div class="mt-2 text-xs text-amber-600">MLFQ</div>
                </div>
            </div>

            <!-- 해결 기법: "에부적" -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">✅ 기아 해결 기법 — <span class="highlight">"에부적"</span></h3>
            <div class="space-y-3 mb-8">
                <div class="strategy-card bg-green-50 rounded-lg p-5 border border-green-200" onclick="toggleStrategy(this)">
                    <div class="strategy-summary flex justify-between items-center">
                        <div><span class="text-green-600 font-bold mr-2">1. 에이징(Aging)</span><span class="text-sm text-gray-600">— 대기 시간 비례 우선순위 상향</span></div>
                        <span class="text-gray-400 text-sm">클릭하여 상세보기 ▼</span>
                    </div>
                    <div class="strategy-detail hidden mt-4 pt-4 border-t border-green-200">
                        <p class="text-sm text-gray-700 mb-2">대기 시간이 길어질수록 프로세스의 우선순위를 점진적으로 상향 조정하여 기아를 방지하는 기법.</p>
                        <ul class="text-sm text-gray-700 space-y-1 ml-4 list-disc">
                            <li>대기 시간 1단위 증가마다 우선순위 1씩 상향</li>
                            <li>일정 임계값 도달 시 최상위 큐로 이동</li>
                            <li>아무리 낮은 우선순위도 충분한 시간이 지나면 반드시 실행</li>
                        </ul>
                    </div>
                </div>
                <div class="strategy-card bg-blue-50 rounded-lg p-5 border border-blue-200" onclick="toggleStrategy(this)">
                    <div class="strategy-summary flex justify-between items-center">
                        <div><span class="text-blue-600 font-bold mr-2">2. Priority Boosting(부스팅)</span><span class="text-sm text-gray-600">— 주기적 최상위 큐 리셋</span></div>
                        <span class="text-gray-400 text-sm">클릭하여 상세보기 ▼</span>
                    </div>
                    <div class="strategy-detail hidden mt-4 pt-4 border-t border-blue-200">
                        <p class="text-sm text-gray-700 mb-2">일정 시간 간격(Boost Interval, S)마다 모든 프로세스를 최상위 큐(Q0)로 이동시키는 방법.</p>
                        <ul class="text-sm text-gray-700 space-y-1 ml-4 list-disc">
                            <li>매개변수 S: 일반적으로 50~200ms 범위에서 설정</li>
                            <li>S가 너무 크면 기아 해결 효과 감소</li>
                            <li>S가 너무 작으면 MLFQ의 분류 효과 약화</li>
                        </ul>
                    </div>
                </div>
                <div class="strategy-card bg-purple-50 rounded-lg p-5 border border-purple-200" onclick="toggleStrategy(this)">
                    <div class="strategy-summary flex justify-between items-center">
                        <div><span class="text-purple-600 font-bold mr-2">3. 적응적 큐 이동</span><span class="text-sm text-gray-600">— Gaming 방지 + 누적 CPU 시간 추적</span></div>
                        <span class="text-gray-400 text-sm">클릭하여 상세보기 ▼</span>
                    </div>
                    <div class="strategy-detail hidden mt-4 pt-4 border-t border-purple-200">
                        <p class="text-sm text-gray-700 mb-2">악의적 프로세스가 TQ 만료 직전 I/O를 요청하여 상위 큐에 머무르는 Gaming 행위 방지.</p>
                        <ul class="text-sm text-gray-700 space-y-1 ml-4 list-disc">
                            <li>큐별 누적 CPU 사용 시간을 추적</li>
                            <li>임계값 초과 시 하위 큐로 강제 이동</li>
                            <li>TQ 잔여 시간이 아닌 총 사용량 기준 판정</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- HRN 공식 및 수치 예시 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">📐 HRN(Highest Response Ratio Next) — 에이징의 수식적 구현</h3>
            <div class="bg-indigo-50 rounded-xl p-6 border border-indigo-200 mb-6">
                <div class="bg-white rounded-lg p-4 border mb-4 text-center">
                    <p class="text-lg font-bold text-indigo-800">우선순위 = (대기시간 + 서비스시간) / 서비스시간 = 1 + (대기시간 / 서비스시간)</p>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full border-collapse text-sm">
                        <thead><tr class="bg-indigo-100">
                            <th class="border border-indigo-200 px-3 py-2 font-bold">프로세스</th>
                            <th class="border border-indigo-200 px-3 py-2 font-bold">서비스시간</th>
                            <th class="border border-indigo-200 px-3 py-2 font-bold">대기시간</th>
                            <th class="border border-indigo-200 px-3 py-2 font-bold">HRN 우선순위</th>
                            <th class="border border-indigo-200 px-3 py-2 font-bold">선택 순서</th>
                        </tr></thead>
                        <tbody>
                            <tr><td class="border border-indigo-200 px-3 py-2 font-medium">P1</td><td class="border border-indigo-200 px-3 py-2">20ms</td><td class="border border-indigo-200 px-3 py-2">40ms</td><td class="border border-indigo-200 px-3 py-2">(40+20)/20 = <strong>3.0</strong></td><td class="border border-indigo-200 px-3 py-2">2</td></tr>
                            <tr class="bg-green-50"><td class="border border-indigo-200 px-3 py-2 font-medium">P2</td><td class="border border-indigo-200 px-3 py-2">5ms</td><td class="border border-indigo-200 px-3 py-2">30ms</td><td class="border border-indigo-200 px-3 py-2">(30+5)/5 = <strong class="text-green-700">7.0</strong></td><td class="border border-indigo-200 px-3 py-2 font-bold text-green-700">1 (최우선)</td></tr>
                            <tr><td class="border border-indigo-200 px-3 py-2 font-medium">P3</td><td class="border border-indigo-200 px-3 py-2">10ms</td><td class="border border-indigo-200 px-3 py-2">10ms</td><td class="border border-indigo-200 px-3 py-2">(10+10)/10 = <strong>2.0</strong></td><td class="border border-indigo-200 px-3 py-2">3</td></tr>
                        </tbody>
                    </table>
                </div>
                <p class="text-xs text-gray-500 mt-3">P2는 서비스시간이 짧지만 대기시간이 길어 HRN 값이 가장 높음 → SJF처럼 짧은 작업에 유리하면서 기아도 방지</p>
            </div>

            <!-- 실무 적용 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">🌐 실무 적용 사례</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="bg-teal-50 rounded-lg p-5 border border-teal-200">
                    <div class="font-bold text-teal-800 mb-2">🐧 Linux CFS (2007~)</div>
                    <p class="text-sm text-gray-700">Red-Black Tree로 <strong>vruntime</strong>(가상 실행 시간)이 가장 작은 프로세스를 선택. 대기가 긴 프로세스일수록 vruntime이 작아져 우선 선택 = 에이징의 현대적 구현.</p>
                </div>
                <div class="bg-sky-50 rounded-lg p-5 border border-sky-200">
                    <div class="font-bold text-sky-800 mb-2">☁️ 클라우드 (AWS EC2)</div>
                    <p class="text-sm text-gray-700">T2/T3 인스턴스의 <strong>CPU Credit 시스템</strong>: 유휴 시 Credit 축적, 버스트 시 소모. 에이징과 유사한 공정 자원 배분. Kubernetes Pod 스케줄러도 유사 메커니즘 적용.</p>
                </div>
            </div>
        </div>
    </section>

    <section id="textbook" class="hidden">
        <div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 animate-fade-in">
            <h2 class="text-xl font-bold text-gray-900 mb-2 flex items-center gap-2">📖 원문 학습</h2>
            <p class="text-sm text-gray-500 mb-6">교재 제1부(상세 해설) 원문을 충실히 재현한 학습 자료입니다.</p>

            <div class="textbook-content">

                <div class="def-box mb-4">
                    <p><strong>2교시형 문제 구조 분석</strong> — 이 문제는 3개의 소문제로 구성되며, 소문제 간에 논리적 발전 관계가 존재한다. 소문제 1: 선점형과 비선점형의 <strong>기초 분류</strong>, 소문제 2: RR, MLQ, MLFQ의 <strong>동작 원리</strong>(기초→단순→복합 진화), 소문제 3: 기아현상과 에이징의 <strong>문제-해결</strong>. 따라서 <strong>분류(기초) → 진화(알고리즘) → 보완(공정성)</strong>의 흐름을 갖는다.</p>
                </div>

                <h3>제1장 선점형과 비선점형 스케줄링 비교 (소문제 1)</h3>

                <h4>1.1 CPU 스케줄링의 개요</h4>
                <p>CPU 스케줄링(CPU Scheduling)이란 다중 프로그래밍(Multiprogramming) 환경에서 준비 상태(Ready State)의 여러 프로세스 중 어떤 프로세스에게 CPU를 할당할지 결정하는 운영체제 커널의 핵심 기능이다. 스케줄링의 목표는 CPU 이용률(Utilization) 극대화, 처리량(Throughput) 극대화, 응답 시간(Response Time) 최소화, 대기 시간(Waiting Time) 최소화, 공정성(Fairness) 확보이다.</p>
                <p>스케줄링 정책은 <strong>CPU를 강제로 회수할 수 있느냐의 여부</strong>에 따라 선점형(Preemptive)과 비선점형(Non-Preemptive)으로 대별된다.</p>

                <h4>1.2 선점형 스케줄링(Preemptive Scheduling)</h4>
                <p>선점형 스케줄링은 현재 실행 중인 프로세스로부터 운영체제가 CPU를 <strong>강제로 회수</strong>할 수 있는 방식이다. 타이머 인터럽트(Timer Interrupt)를 기반으로 Time Quantum(시간 할당량)이 만료되거나, 더 높은 우선순위의 프로세스가 도착하면 현재 프로세스를 중단하고 문맥 교환(Context Switching)을 수행한다.</p>
                <div class="insight-box"><span class="text-sm text-amber-800"><strong>핵심 특성</strong>: 응답 시간이 짧아 대화형(Interactive) 시스템에 적합하며, 실시간 시스템에서 긴급한 태스크를 즉시 처리할 수 있다. 그러나 빈번한 문맥 교환으로 인한 오버헤드가 발생하며, 공유 자원 접근 시 동기화 문제(Race Condition)를 고려해야 한다.</span></div>
                <p><strong>대표 알고리즘</strong>: RR(Round Robin), SRT(Shortest Remaining Time), 선점형 Priority, MLFQ</p>

                <h4>1.3 비선점형 스케줄링(Non-Preemptive Scheduling)</h4>
                <p>비선점형 스케줄링은 프로세스가 CPU를 할당받으면 <strong>자발적으로 반납</strong>(I/O 요청 또는 종료)할 때까지 CPU를 점유하는 방식이다. 운영체제가 강제로 CPU를 회수하지 않으므로 문맥 교환 오버헤드가 적고 구현이 단순하다.</p>
                <div class="insight-box"><span class="text-sm text-amber-800"><strong>핵심 특성</strong>: 문맥 교환 비용이 낮아 배치(Batch) 처리 시스템에 적합하나, 긴 프로세스가 CPU를 오래 점유하면 다른 프로세스의 응답 시간이 급격히 증가하는 <strong>호위 효과(Convoy Effect)</strong>가 발생한다.</span></div>
                <p><strong>대표 알고리즘</strong>: FCFS(First Come First Served), SJF(Shortest Job First), 비선점형 Priority, HRN</p>

                <h4>1.4 체계적 비교표</h4>
                <table>
                    <thead><tr><th>비교 기준</th><th>선점형(Preemptive)</th><th>비선점형(Non-Preemptive)</th></tr></thead>
                    <tbody>
                        <tr><td>CPU 회수 방식</td><td>타이머 인터럽트에 의한 강제 회수</td><td>프로세스 자발적 반납(I/O, 종료)</td></tr>
                        <tr><td>문맥 교환 빈도</td><td>높음 (오버헤드 발생)</td><td>낮음 (오버헤드 적음)</td></tr>
                        <tr><td>응답 시간</td><td>짧음 (대화형 시스템에 유리)</td><td>길어질 수 있음 (Convoy Effect)</td></tr>
                        <tr><td>처리량(Throughput)</td><td>오버헤드로 인해 다소 감소</td><td>문맥 교환 적어 배치 처리에 유리</td></tr>
                        <tr><td>공정성</td><td>높음 (모든 프로세스에 CPU 배분)</td><td>낮음 (긴 프로세스에 유리)</td></tr>
                        <tr><td>동기화 필요성</td><td>높음 (Race Condition 대비 필수)</td><td>낮음 (실행 중 중단 없음)</td></tr>
                        <tr><td>실시간 지원</td><td>가능 (긴급 태스크 즉시 처리)</td><td>불가 (실행 완료까지 대기)</td></tr>
                        <tr><td>구현 복잡도</td><td>높음 (인터럽트, 동기화 처리)</td><td>낮음 (단순한 큐 관리)</td></tr>
                        <tr><td>적합 환경</td><td>대화형, 실시간, 클라우드</td><td>배치 처리, 단순 임베디드</td></tr>
                        <tr><td>대표 알고리즘</td><td>RR, SRT, MLFQ</td><td>FCFS, SJF, HRN</td></tr>
                    </tbody>
                </table>

                <h3>제2장 RR, MLQ, MLFQ 알고리즘 동작 원리 및 장단점 (소문제 2)</h3>

                <h4>2.1 스케줄링 알고리즘의 진화 흐름</h4>
                <p>스케줄링 알고리즘은 단순한 큐 관리에서 지능적 큐 관리로 진화해왔다.</p>
                <pre><code>FCFS → SJF → RR → MLQ → MLFQ
(단순순서) (최적화) (공정성) (분류) (적응적 분류)</code></pre>
                <p>이 진화 과정에서 핵심적 변화는 <strong>프로세스의 성격(CPU-Bound vs I/O-Bound)을 어떻게 구분하고 차별적으로 처리할 것인가</strong>에 있다.</p>

                <h4>2.2 RR(Round Robin) 알고리즘</h4>
                <p><strong>동작 원리</strong>: 모든 프로세스에게 동일한 시간 할당량(Time Quantum, q)을 부여하고, 큐를 순환(Circular)하며 CPU를 할당한다. 시간 할당량이 만료되면 해당 프로세스는 준비 큐(Ready Queue)의 맨 뒤로 이동하고, 다음 프로세스에게 CPU를 넘긴다.</p>
                <p><strong>동작 예시</strong> (Time Quantum = 4ms):</p>
                <table>
                    <thead><tr><th>프로세스</th><th>도착시간</th><th>실행시간(Burst)</th><th>실행 순서</th></tr></thead>
                    <tbody>
                        <tr><td>P1</td><td>0</td><td>10ms</td><td>0~4 → 8~12 → 16~18</td></tr>
                        <tr><td>P2</td><td>0</td><td>4ms</td><td>4~8 (완료)</td></tr>
                        <tr><td>P3</td><td>0</td><td>6ms</td><td>12~16 → 18~20</td></tr>
                    </tbody>
                </table>
                <p>평균 대기시간 = (8+4+12)/3 = 8ms</p>
                <p><strong>Time Quantum의 영향</strong>:</p>
                <ul>
                    <li>q → ∞: FCFS와 동일 (문맥 교환 없음)</li>
                    <li>q → 0: Processor Sharing (문맥 교환 오버헤드 극대화)</li>
                    <li><strong>최적 q</strong>: 프로세스 CPU Burst의 80%가 q 이내에 완료되는 수준 (일반적으로 10~100ms)</li>
                </ul>
                <p><strong>장단점</strong>:</p>
                <table>
                    <thead><tr><th>장점</th><th>단점</th></tr></thead>
                    <tbody>
                        <tr><td>공정성 보장 (모든 프로세스에 동등한 기회)</td><td>Time Quantum 설정에 민감</td></tr>
                        <tr><td>응답 시간 예측 가능</td><td>CPU-Bound와 I/O-Bound 차별 불가</td></tr>
                        <tr><td>기아(Starvation) 발생하지 않음</td><td>문맥 교환 오버헤드</td></tr>
                    </tbody>
                </table>

                <h4>2.3 MLQ(Multi-Level Queue) 알고리즘</h4>
                <p><strong>동작 원리</strong>: 준비 큐를 여러 개의 독립 큐로 분리하고, 각 큐에 고정된 우선순위를 부여한다. 프로세스는 속성(유형)에 따라 특정 큐에 <strong>영구적으로 배정</strong>되며, 큐 간 이동이 불가능하다.</p>
                <p><strong>큐 구성 예시</strong>:</p>
                <table>
                    <thead><tr><th>큐 번호</th><th>큐 이름</th><th>우선순위</th><th>스케줄링 정책</th><th>프로세스 유형</th></tr></thead>
                    <tbody>
                        <tr><td>Q1</td><td>시스템 프로세스</td><td>최우선</td><td>선점형 Priority</td><td>커널, 드라이버</td></tr>
                        <tr><td>Q2</td><td>대화형 프로세스</td><td>높음</td><td>RR (q=20ms)</td><td>편집기, 브라우저</td></tr>
                        <tr><td>Q3</td><td>배치 프로세스</td><td>낮음</td><td>FCFS</td><td>컴파일, 백업</td></tr>
                    </tbody>
                </table>
                <p><strong>큐 간 스케줄링</strong>: 상위 큐에 프로세스가 있으면 하위 큐는 실행 불가(절대적 우선순위). 또는 큐별 CPU 시간 비율을 배분하는 방식(예: Q1 50%, Q2 30%, Q3 20%)도 가능하다.</p>
                <table>
                    <thead><tr><th>장점</th><th>단점</th></tr></thead>
                    <tbody>
                        <tr><td>프로세스 유형별 차별화된 서비스 가능</td><td>큐 간 이동 불가 → 유연성 부족</td></tr>
                        <tr><td>각 큐에 최적 스케줄링 정책 적용</td><td>하위 큐에서 기아(Starvation) 발생 가능</td></tr>
                        <tr><td>구현이 MLFQ보다 단순</td><td>프로세스 성격 변화에 적응 불가</td></tr>
                    </tbody>
                </table>

                <h4>2.4 MLFQ(Multi-Level Feedback Queue) 알고리즘</h4>
                <p><strong>동작 원리</strong>: MLQ를 발전시켜 프로세스가 <strong>큐 간 이동이 가능</strong>한 구조이다. 프로세스의 실행 이력(CPU 사용량, I/O 빈도)을 관찰하여 동적으로 큐를 재배정한다. Fernando Corbató가 1962년 CTSS(Compatible Time-Sharing System)에서 최초 구현하였으며, 2003년 Solaris 10의 TS(Time Sharing) 스케줄러에도 MLFQ 원리가 적용되어 있다.</p>
                <p><strong>핵심 규칙</strong> (Arpaci-Dusseau, OSTEP 기준):</p>
                <ul>
                    <li>1. Priority(A) > Priority(B)이면 A를 실행</li>
                    <li>2. Priority(A) = Priority(B)이면 RR로 실행</li>
                    <li>3. 프로세스가 최초 진입하면 최상위 큐에 배치</li>
                    <li>4. 프로세스가 Time Quantum을 모두 사용하면 하위 큐로 이동 (CPU-Bound 판정)</li>
                    <li>5. 프로세스가 Time Quantum 이내에 I/O를 요청하면 현재 큐 유지 (I/O-Bound 판정)</li>
                </ul>
                <p><strong>동작 흐름</strong>:</p>
                <!-- MLFQ 큐 구조 시각화 (ASCII→HTML) -->
                <div style="background:linear-gradient(to bottom,#f5f3ff,#eef2ff);border:1px solid #c7d2fe;border-radius:12px;padding:1.5rem;margin-bottom:1rem;">
                    <div style="max-width:500px;margin:0 auto;">
                        <div style="background:#e9d5ff;border:2px solid #a78bfa;border-radius:12px 12px 0 0;padding:12px 16px;">
                            <strong style="color:#6d28d9;">Q0</strong> <span style="color:#7c3aed;font-size:0.9em;">(최우선, q=8ms, RR)</span>
                            <span style="float:right;font-size:0.8em;color:#6d28d9;">← 신규 프로세스 진입</span>
                            <div style="font-size:0.85em;color:#7c3aed;margin-top:4px;">I/O-Bound 프로세스 유지</div>
                        </div>
                        <div style="text-align:center;color:#7c3aed;font-weight:bold;padding:2px 0;">↓ TQ 만료</div>
                        <div style="background:#c7d2fe;border:2px solid #818cf8;padding:12px 16px;">
                            <strong style="color:#4338ca;">Q1</strong> <span style="color:#4f46e5;font-size:0.9em;">(중간, q=16ms, RR)</span>
                            <span style="float:right;font-size:0.8em;color:#4338ca;">← Q0에서 이동</span>
                            <div style="font-size:0.85em;color:#4f46e5;margin-top:4px;">혼합형 프로세스</div>
                        </div>
                        <div style="text-align:center;color:#4f46e5;font-weight:bold;padding:2px 0;">↓ TQ 만료</div>
                        <div style="background:#dbeafe;border:2px solid #60a5fa;border-radius:0 0 12px 12px;padding:12px 16px;">
                            <strong style="color:#1e40af;">Q2</strong> <span style="color:#2563eb;font-size:0.9em;">(최하위, FCFS)</span>
                            <span style="float:right;font-size:0.8em;color:#1e40af;">← Q1에서 이동</span>
                            <div style="font-size:0.85em;color:#2563eb;margin-top:4px;">CPU-Bound 프로세스</div>
                        </div>
                    </div>
                </div>
                <p><strong>MLFQ의 핵심 차별점</strong>: 프로세스의 과거 행동(CPU 사용 패턴)을 기반으로 미래 행동을 <strong>예측</strong>한다. I/O를 자주 요청하는 프로세스는 I/O-Bound로 판정하여 상위 큐에 유지하고, CPU를 오래 사용하는 프로세스는 CPU-Bound로 판정하여 하위 큐로 이동시킨다.</p>
                <table>
                    <thead><tr><th>장점</th><th>단점</th></tr></thead>
                    <tbody>
                        <tr><td>프로세스 성격을 자동으로 분류</td><td>매개변수 설정 복잡 (큐 수, TQ, 이동 규칙)</td></tr>
                        <tr><td>응답 시간과 처리량 동시 최적화</td><td>하위 큐에서 기아 가능 (Boosting으로 해결)</td></tr>
                        <tr><td>대부분의 현대 OS에서 채택</td><td>악의적 프로세스의 Gaming 문제</td></tr>
                    </tbody>
                </table>

                <h4>2.5 RR, MLQ, MLFQ 종합 비교표</h4>
                <table>
                    <thead><tr><th>비교 기준</th><th>RR</th><th>MLQ</th><th>MLFQ</th></tr></thead>
                    <tbody>
                        <tr><td>큐 구조</td><td>단일 큐</td><td>다수 고정 큐</td><td>다수 피드백 큐</td></tr>
                        <tr><td>큐 간 이동</td><td>해당 없음</td><td>불가</td><td>가능 (핵심 특징)</td></tr>
                        <tr><td>프로세스 분류</td><td>미분류 (동일 취급)</td><td>사전 분류 (고정)</td><td>동적 분류 (적응적)</td></tr>
                        <tr><td>기아 발생</td><td>없음</td><td>하위 큐 기아 가능</td><td>하위 큐 기아 가능 (에이징 필요)</td></tr>
                        <tr><td>적합 환경</td><td>단순 Time-Sharing</td><td>프로세스 유형 명확</td><td>범용 (현대 OS 표준)</td></tr>
                        <tr><td>복잡도</td><td>낮음</td><td>중간</td><td>높음</td></tr>
                    </tbody>
                </table>

                <h3>제3장 기아현상 원인 및 에이징 기법 해결 방안 (소문제 3)</h3>

                <h4>3.1 기아현상(Starvation)의 정의와 원인</h4>
                <p>기아현상(Starvation)이란 특정 프로세스가 CPU를 무한히 대기하여 실행되지 못하는 현상이다. 기아는 시스템 교착상태(Deadlock)와 구별되어야 하며, 교착상태는 자원의 순환 대기로 인한 진행 불가 상태인 반면, 기아는 자원 할당 정책의 불공정으로 인한 무한 대기 상태이다.</p>
                <p><strong>기아 발생 원인</strong>:</p>
                <table>
                    <thead><tr><th>원인</th><th>설명</th><th>발생 상황</th></tr></thead>
                    <tbody>
                        <tr><td>우선순위 기반 스케줄링</td><td>높은 우선순위 프로세스가 지속적으로 도착하면 낮은 우선순위 프로세스가 영구 대기</td><td>MLQ, 고정 우선순위 스케줄링</td></tr>
                        <tr><td>SJF/SRT에서의 긴 작업</td><td>짧은 작업이 계속 도착하면 긴 작업이 무한 대기</td><td>SJF, SRT 알고리즘</td></tr>
                        <tr><td>MLFQ 하위 큐 고착</td><td>CPU-Bound 프로세스가 최하위 큐로 이동 후 상위 큐에 의해 지속 선점</td><td>MLFQ</td></tr>
                    </tbody>
                </table>

                <h4>3.2 에이징(Aging) 기법</h4>
                <p>에이징(Aging)이란 대기 시간이 길어질수록 프로세스의 우선순위를 점진적으로 상향 조정하여 기아를 방지하는 기법이다. 시간의 경과에 따라 우선순위를 동적으로 변경하므로, 아무리 낮은 우선순위의 프로세스도 충분한 시간이 지나면 반드시 실행될 수 있다.</p>
                <p><strong>에이징의 동작 원리</strong>:</p>
                <ul>
                    <li>대기 시간 1단위 증가마다 우선순위를 1씩 상향</li>
                    <li>일정 임계값에 도달하면 최상위 큐로 이동 (MLFQ의 경우)</li>
                    <li><strong>Priority Boosting</strong>: 주기적으로(예: 100ms마다) 모든 프로세스를 최상위 큐로 리셋</li>
                </ul>

                <h4>3.3 HRN(Highest Response Ratio Next) 스케줄링과 에이징 연계</h4>
                <p>HRN은 에이징 개념을 수식으로 구현한 대표적 알고리즘이다.</p>
                <p><strong>HRN 우선순위 공식</strong>:</p>
                <pre><code>우선순위 = (대기시간 + 서비스시간) / 서비스시간
         = 1 + (대기시간 / 서비스시간)</code></pre>
                <p><strong>수치 예시</strong>:</p>
                <table>
                    <thead><tr><th>프로세스</th><th>서비스시간</th><th>대기시간</th><th>HRN 우선순위</th><th>선택 순서</th></tr></thead>
                    <tbody>
                        <tr><td>P1</td><td>20ms</td><td>40ms</td><td>(40+20)/20 = 3.0</td><td>2</td></tr>
                        <tr><td>P2</td><td>5ms</td><td>30ms</td><td>(30+5)/5 = 7.0</td><td>1 (최우선)</td></tr>
                        <tr><td>P3</td><td>10ms</td><td>10ms</td><td>(10+10)/10 = 2.0</td><td>3</td></tr>
                    </tbody>
                </table>
                <p>P2는 서비스시간이 짧지만 대기시간이 길어 HRN 값이 가장 높다. SJF처럼 짧은 작업에 유리하면서도, 대기시간이 길어지면 긴 작업도 우선순위가 올라가므로 기아를 방지한다.</p>

                <h4>3.4 MLFQ에서의 기아 해결 — Priority Boosting</h4>
                <p>MLFQ에서 기아를 해결하는 대표적 방법은 <strong>Priority Boosting</strong>(우선순위 부스팅)이다.</p>
                <ul>
                    <li><strong>메커니즘</strong>: 일정 시간 간격(Boost Interval, S)마다 모든 프로세스를 최상위 큐(Q0)로 이동</li>
                    <li><strong>효과</strong>: 하위 큐에 고착된 CPU-Bound 프로세스도 주기적으로 상위 큐에서 실행 기회를 얻음</li>
                    <li><strong>매개변수 S의 설정</strong>: S가 너무 크면 기아 해결 효과 감소, S가 너무 작으면 MLFQ의 분류 효과 약화. 일반적으로 50~200ms 범위에서 설정</li>
                </ul>
                <p><strong>Gaming 방지</strong>: 악의적 프로세스가 Time Quantum 만료 직전에 I/O를 요청하여 상위 큐에 머무르는 행위를 방지하기 위해, 큐별 누적 CPU 사용 시간을 추적하여 임계값 초과 시 하위 큐로 이동시키는 정책을 적용한다.</p>

                <h4>3.5 실무 적용 사례</h4>
                <p><strong>Linux CFS(Completely Fair Scheduler)</strong>: Linux 커널 2.6.23(2007)부터 도입된 CFS는 Red-Black Tree를 사용하여 가상 실행 시간(vruntime)이 가장 작은 프로세스를 선택한다. 이는 에이징의 정신을 구현한 것으로, 대기 시간이 긴 프로세스일수록 vruntime이 작아져 우선 선택된다. Google의 Borg 시스템(2015)과 Kubernetes의 Pod 스케줄러도 공정성과 자원 효율 사이의 균형을 위해 유사한 메커니즘을 적용하고 있다.</p>
                <p><strong>클라우드 환경 적용</strong>: AWS EC2의 CPU Credit 시스템에서도 에이징과 유사한 개념이 적용된다. T2/T3 인스턴스는 유휴 시 CPU Credit을 축적하고, 버스트 시 소모하는 구조로 공정한 자원 배분을 달성한다.</p>

                <h3>제4장 통합 분석 — 소문제 간 연결</h3>
                <p>소문제 1의 선점/비선점 분류는 스케줄링 정책의 <strong>기본 축</strong>을 제공한다. 이 기본 축 위에서 소문제 2의 RR→MLQ→MLFQ는 "공정성과 효율성을 동시에 달성하기 위해 알고리즘이 어떻게 진화했는가"를 보여준다. 소문제 3의 기아현상과 에이징은 이 진화 과정에서 발생한 <strong>부작용(기아)과 그 해결책</strong>이다.</p>
                <div class="insight-box"><span class="text-sm text-amber-800">이 세 소문제는 <strong>분류(기초) → 진화(알고리즘) → 보완(공정성)</strong>의 논리적 연결 구조를 갖는다. 결론에서 "스케줄링 알고리즘의 핵심 목표는 처리량 극대화와 응답 시간 최소화의 균형이며, MLFQ + 에이징이 현대 OS에서 이 균형을 달성하는 표준 메커니즘"이라고 통합하면 답안의 완결성이 높아진다.</span></div>

            </div><!-- textbook-content -->
        </div>
    </section>

    <section id="script" class="hidden">
        <div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 animate-fade-in">
            <div class="flex items-center gap-3 mb-4">
                <h2 class="text-xl font-bold text-gray-900">🎬 강의 스크립트</h2>
                <span class="bg-amber-100 text-amber-800 text-xs font-bold px-3 py-1 rounded-full border border-amber-300">🔒 멘토 전용</span>
            </div>
            <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-6 text-sm text-amber-800">
                이 탭은 멘토 전용 콘텐츠입니다. URL에 <code class="bg-amber-100 px-1 rounded">?mentor=true</code> 파라미터를 추가하면 접근할 수 있습니다.
            </div>

            <div class="textbook-content">
                <p class="text-sm text-gray-500 italic mb-6">멘토 총평 영상 (약 20분) — 오프라인 강의 화법</p>

                <h4>🎬 [도입부 — 약 3분]</h4>
                <p>안녕하세요, 여러분. 오늘은 운영체제 핵심 중의 핵심, CPU 스케줄링을 다뤄봅시다. 2교시형 문제로 소문제가 3개예요.</p>
                <p>소문제 1이 선점형과 비선점형 비교, 소문제 2가 RR, MLQ, MLFQ 알고리즘의 동작 원리, 소문제 3이 기아현상과 에이징 기법이에요.</p>
                <p>이 세 개의 연결 관계를 먼저 파악해야 해요. 소문제 1에서 "스케줄링에는 큰 두 줄기가 있다"는 걸 보여주고, 소문제 2에서 "그 위에서 알고리즘이 어떻게 진화했는지"를 설명하고, 소문제 3에서 "진화 과정에서 생긴 기아 문제를 어떻게 해결하는지"로 마무리하는 거예요. <strong>분류 → 진화 → 보완</strong>이라는 흐름이죠. 서론에서 이걸 한 줄로 예고하면 채점관이 "구조를 잡았구나" 하고 좋은 인상을 받거든요.</p>

                <h4>🎬 [핵심 설명 — 소문제 1: 선점형 vs 비선점형 (약 4분)]</h4>
                <p>자, 소문제 1부터 갑시다. 선점형과 비선점형의 핵심 차이는 딱 하나예요. <strong>CPU를 강제로 뺏을 수 있느냐 없느냐</strong>.</p>
                <p>선점형은 운영체제가 타이머 인터럽트를 걸어서 "니 시간 다 됐어, CPU 내놔"하고 강제로 빼앗는 거예요. 그래서 응답 시간이 짧아요. 대화형 시스템이나 실시간 시스템에 필수적이죠. 대신 문맥 교환이 자주 일어나니까 오버헤드가 있고, 공유 자원에 대한 동기화 문제도 신경 써야 해요. 대표적으로 RR, SRT, MLFQ가 있어요.</p>
                <p>비선점형은 반대예요. 프로세스가 자발적으로 CPU를 반납할 때까지 기다리는 거예요. I/O 요청하거나 실행이 끝나야 다음 프로세스한테 넘어가는 거죠. 운영체제가 중간에 개입하지 않으니까 문맥 교환이 적어서 배치 처리에 유리한데, 큰 문제가 있어요. <strong>호위 효과(Convoy Effect)</strong>라고, 오래 걸리는 프로세스 하나가 CPU를 꽉 잡고 있으면 뒤에 짧은 프로세스들이 줄줄이 기다려야 하는 거예요. FCFS, SJF, HRN이 대표적이에요.</p>
                <p>비교표를 그릴 때 핵심 기준은 <span class="highlight">"회응공실적대"</span> — 회수방식, 응답시간, 공정성, 실시간 지원, 적합 환경, 대표 알고리즘. 이 6개만 확실히 채워도 충분해요. 10개 다 쓸 여유가 있으면 동기화 필요성, 구현 복잡도, 문맥 교환 빈도, 처리량까지 추가하면 완벽하죠.</p>

                <h4>🎬 [핵심 설명 — 소문제 2: RR → MLQ → MLFQ (약 7분)]</h4>
                <p>소문제 2, 알고리즘 동작 원리로 가봅시다. 여기가 분량이 가장 많아야 해요.</p>
                <p>먼저 <strong>RR(Round Robin)</strong>. 이건 가장 직관적인 알고리즘이에요. 모든 프로세스에게 똑같은 시간(Time Quantum)을 주고 돌아가면서 쓰게 하는 거예요. 식당 뷔페에서 줄 서서 한 접시씩 가져가는 거랑 비슷해요. 공정하잖아요? 기아가 발생하지 않는 게 가장 큰 장점이에요.</p>
                <p>근데 Time Quantum 설정이 중요해요. TQ를 너무 크게 잡으면 FCFS랑 다를 바가 없어지고, 너무 작게 잡으면 문맥 교환만 계속 하느라 실제 작업은 못 하거든요. 문맥 교환 한 번에 보통 10~20마이크로초가 드는데, TQ가 1ms면 작업보다 교환에 더 많은 시간을 쓰게 되는 거예요. 경험적으로 CPU Burst의 80%가 TQ 안에 끝나는 수준, 보통 10~100ms 정도가 적절해요. 이 숫자를 답안에 꼭 쓰세요.</p>
                <p><strong>MLQ(Multi-Level Queue)</strong>는 RR의 한계를 개선한 거예요. RR은 모든 프로세스를 똑같이 취급하잖아요? 근데 실제로는 시스템 프로세스, 대화형 프로세스, 배치 프로세스의 특성이 다 달라요. 그래서 큐를 여러 개로 나누고, 프로세스 유형별로 다른 큐에 배정하는 거예요. 시스템 프로세스는 최우선 큐, 대화형은 중간 큐, 배치는 하위 큐. 각 큐마다 다른 스케줄링 정책을 적용할 수 있어요.</p>
                <p>문제는 뭐냐면, 큐 간 이동이 안 돼요. 한번 배치 큐에 들어가면 영원히 거기 있어야 해요. 그리고 상위 큐에 프로세스가 계속 들어오면 하위 큐는 영원히 실행 못 하는 <strong>기아 현상</strong>이 발생할 수 있어요.</p>
                <p>그래서 나온 게 <strong>MLFQ(Multi-Level Feedback Queue)</strong>예요. 이게 핵심 중의 핵심이에요. MLQ에서 "Feedback"이 붙었다는 건 큐 간 이동이 가능하다는 뜻이에요. 프로세스의 행동을 관찰해서 CPU-Bound인지 I/O-Bound인지 자동으로 분류하는 거예요.</p>
                <p>동작 규칙 5개를 외워야 해요. <span class="highlight">"우동최하유"</span>. 우선순위가 높으면 먼저 실행, 동등하면 RR, 최초에는 최상위 큐 진입, TQ 다 쓰면 하위 큐로 이동, TQ 안에 I/O 하면 유지. 이 5개 규칙이 MLFQ의 전부예요.</p>
                <p>왜 이렇게 하냐면요, I/O-Bound 프로세스는 CPU를 조금만 쓰고 금방 I/O를 요청하잖아요? 그러니까 TQ 안에 I/O를 요청해서 상위 큐에 남아있게 되는 거예요. 반면에 CPU-Bound 프로세스는 CPU를 오래 쓰니까 TQ를 다 소진하고 하위 큐로 내려가는 거죠. 이렇게 하면 I/O-Bound에게 빠른 응답을, CPU-Bound에게 충분한 처리 시간을 보장할 수 있어요. 정말 똑똑한 설계이거든요.</p>
                <p>Fernando Corbató가 1962년에 CTSS에서 처음 이걸 구현했는데, 이 업적으로 1990년에 튜링상을 받았어요. 현대의 거의 모든 범용 OS가 MLFQ 기반이에요. 이런 배경 지식을 한 줄 써주면 깊이가 확실히 달라져요.</p>

                <h4>🎬 [핵심 설명 — 소문제 3: 기아현상과 에이징 (약 4분)]</h4>
                <p>소문제 3, 기아현상과 에이징으로 가봅시다.</p>
                <p>기아현상이 뭐냐면, 낮은 우선순위 프로세스가 CPU를 영원히 못 받는 거예요. 높은 우선순위 프로세스가 계속 들어오면, 낮은 애는 줄만 서다가 끝나는 거죠. MLQ에서도, MLFQ의 하위 큐에서도 발생할 수 있어요.</p>
                <p>해결책이 <strong>에이징(Aging)</strong>이에요. 기다린 시간이 길어질수록 우선순위를 올려주는 거예요. "오래 기다렸으니까 이제 너 차례야"하고 밀어주는 거죠.</p>
                <p>이걸 수식으로 구현한 게 <strong>HRN(Highest Response Ratio Next)</strong>이에요. 공식이 (대기시간 + 서비스시간) / 서비스시간이에요. 숫자를 넣어볼게요. 서비스시간이 5ms이고 대기시간이 30ms인 프로세스는 HRN 값이 (30+5)/5 = 7이에요. 서비스시간이 20ms이고 대기시간이 40ms인 프로세스는 (40+20)/20 = 3이에요. 서비스시간이 짧아도 오래 기다리면 HRN 값이 올라가서 먼저 선택되는 거예요. 기아를 수학적으로 해결한 거죠. 이 계산 예시를 답안에 꼭 넣으세요.</p>
                <p>MLFQ에서는 <strong>Priority Boosting</strong>이라는 방법을 써요. 일정 시간(50~200ms)마다 모든 프로세스를 최상위 큐로 올려버리는 거예요. 그러면 하위 큐에 갇혀있던 프로세스도 다시 기회를 얻게 되죠.</p>
                <p>여기서 하나 더 중요한 게 Gaming 방지예요. 악의적인 프로세스가 TQ 만료 직전에 일부러 I/O를 요청해서 상위 큐에 계속 머무르려는 거예요. 이걸 방지하려면 큐별로 누적 CPU 사용 시간을 추적해서, 일정 시간 이상 쓰면 하위 큐로 내리는 정책을 적용해야 해요. 이런 세부 메커니즘까지 쓰면 "이 사람은 MLFQ를 깊이 이해하고 있구나" 하는 인상을 줄 수 있거든요.</p>
                <p>그리고 현대적 사례로 <strong>Linux CFS</strong>(Completely Fair Scheduler)를 한 줄 언급해주면 좋아요. CFS는 Red-Black Tree로 vruntime이 가장 작은 프로세스를 선택하는데, 이게 에이징의 정신을 구현한 거예요. 대기 시간이 길수록 vruntime이 작아지니까 먼저 선택되는 거죠. Kubernetes의 Pod 스케줄러도 비슷한 원리를 쓰고 있어요. 이런 현대적 연결을 보여주면 시야가 넓은 답안이 돼요.</p>

                <h4>🎬 [답안 작성 팁 — 약 3분]</h4>
                <p>실전 팁 정리할게요.</p>
                <p>첫 번째, 분량 배분은 서론 10%, 소문제 1이 25%, 소문제 2가 30%, 소문제 3이 25%, 결론 10%예요. 소문제 2가 가장 비중이 커요. RR, MLQ, MLFQ 세 개를 다 설명해야 하니까요.</p>
                <p>두 번째, 소문제 2에서 MLFQ의 큐 구조도를 반드시 그려주세요. Q0, Q1, Q2 세 단계로 그리고, TQ 만료 시 아래로 이동하는 화살표, I/O 시 현재 큐 유지하는 화살표를 표시하면 돼요. 이 도식 하나가 글 100자 이상의 가치가 있어요.</p>
                <p>세 번째, 소문제 3에서 HRN 공식을 쓸 때 반드시 숫자를 대입해서 계산 결과를 보여주세요. "공식은 이거다"만 쓰면 암기한 거고, 숫자를 넣어서 결과를 보여주면 이해한 거거든요. 3개 프로세스 정도 넣어서 우선순위가 어떻게 바뀌는지 보여주면 완벽해요.</p>
                <p>결론에서는 "스케줄링의 궁극적 목표는 처리량과 응답성의 균형이며, MLFQ + 에이징이 이 균형을 달성하는 현대 OS의 표준 메커니즘"이라고 통합해주시고, Linux CFS나 Kubernetes 스케줄러까지 언급하면 현대적 시야를 보여줄 수 있어요.</p>

                <h4>🎬 [마무리 — 약 2분]</h4>
                <p>자, 오늘 핵심을 정리합니다.</p>
                <p>비교 핵심 <span class="highlight">"회응공실적대"</span>, MLFQ 5규칙 <span class="highlight">"우동최하유"</span>, 기아 해결 <span class="highlight">"에부적"</span>. 이 세 개 두문자어를 외우면 뼈대가 완성돼요.</p>
                <p>그리고 숫자를 기억하세요. Time Quantum은 "10~100ms, CPU Burst 80%가 완료되는 수준". HRN 공식에 구체적 수치를 대입한 예시. Priority Boosting 간격 "50~200ms". 이런 숫자들이 답안의 구체성을 만들어줘요.</p>
                <p>이 문제의 핵심 메시지는 "스케줄링은 공정성과 효율성의 균형"이에요. RR에서 시작해서 MLQ로 분류하고, MLFQ로 적응적 분류를 하고, 에이징으로 공정성을 보완하는 거. 이 진화 과정을 보여주면 합격권을 넘는 답안이 됩니다.</p>
                <p>특히 요즘 클라우드 환경에서는 스케줄링이 더 중요해졌어요. 하나의 물리 서버에서 수십 개의 가상 머신이나 컨테이너가 CPU를 경쟁하잖아요? AWS EC2의 T2/T3 인스턴스가 CPU Credit 시스템을 쓰는 것도 결국 공정한 자원 배분을 위한 스케줄링 전략이에요. 결론에서 이런 현대적 관점을 한 줄 넣어주면 "이론만 아는 게 아니라 현업도 안다"는 인상을 줄 수 있어요.</p>
                <p>다음 강의에서 뵙겠습니다. 감사합니다.</p>
            </div>
        </div>
    </section>

    <section id="quiz" class="hidden">
        <div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 animate-fade-in">
            <h2 class="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2">🧠 퀴즈 &amp; 암기</h2>

            <!-- AI 실전 퀴즈 -->
            <div class="bg-indigo-50 rounded-xl p-6 mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold text-indigo-900">🤖 AI 실전 퀴즈</h3>
                    <button onclick="generateQuiz()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm font-bold transition-colors">새 문제 생성</button>
                </div>
                <div id="quiz-loading" class="hidden text-center py-8"><div class="typing-indicator inline-flex"><span></span><span></span><span></span></div><p class="text-sm text-gray-500 mt-2">AI가 문제를 생성하고 있습니다...</p></div>
                <div id="quiz-container" class="hidden">
                    <div class="flex items-start gap-3 mb-4">
                        <span id="quiz-type-badge" class="bg-indigo-100 text-indigo-800 text-xs font-bold px-2 py-1 rounded whitespace-nowrap mt-1">객관식</span>
                        <p id="quiz-question" class="text-gray-900 font-medium"></p>
                    </div>
                    <div id="quiz-options" class="space-y-2 mb-4"></div>
                    <div id="quiz-input-area" class="hidden mb-4">
                        <div class="flex gap-2"><input type="text" id="quiz-answer-input" placeholder="정답을 입력하세요..." class="flex-grow border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-sm" onkeypress="if(event.key==='Enter')checkShortAnswer()"><button onclick="checkShortAnswer()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm font-bold">제출</button></div>
                    </div>
                </div>
                <div id="quiz-placeholder" class="border-2 border-dashed border-indigo-200 rounded-lg p-8 text-center"><p class="text-indigo-400 text-sm">위의 "새 문제 생성" 버튼을 클릭하면<br>AI가 랜덤 퀴즈를 출제합니다.</p></div>
                <div id="quiz-feedback" class="hidden mt-4"></div>
            </div>

            <!-- 암기노트 3단 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">📝 암기 노트 — 골격 답안 구조</h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                <div class="bg-blue-50 rounded-lg p-5 border border-blue-200">
                    <div class="text-blue-700 font-bold text-sm mb-2">1단락 요약</div>
                    <p class="text-sm text-gray-700 leading-relaxed">CPU 스케줄링은 선점형(강제 회수)과 비선점형(자발적 반납)으로 대별되며, RR→MLQ→MLFQ로 진화. MLFQ+에이징이 현대 OS 표준.</p>
                </div>
                <div class="bg-green-50 rounded-lg p-5 border border-green-200">
                    <div class="text-green-700 font-bold text-sm mb-2">2단락 요약</div>
                    <p class="text-sm text-gray-700 leading-relaxed">선점/비선점의 핵심 차이는 CPU 강제 회수 여부. 비교 기준 "회응공실적대". MLFQ는 5규칙 "우동최하유"로 CPU/IO-Bound를 동적 분류하며, 기아 해결에 에이징과 Priority Boosting(50~200ms) 적용.</p>
                </div>
                <div class="bg-purple-50 rounded-lg p-5 border border-purple-200">
                    <div class="text-purple-700 font-bold text-sm mb-2">3단락 요약</div>
                    <p class="text-sm text-gray-700 leading-relaxed">소문제 1: 비교표(10기준)+Convoy/Race. 소문제 2: RR(TQ 10~100ms, 80%)+MLQ(고정큐)+MLFQ(Corbató 1962, 피드백큐)+종합비교표. 소문제 3: 기아"우짧하"+에이징+HRN공식(수치대입)+Boosting+Gaming방지. 결론: CFS(vruntime)+K8s 스케줄러.</p>
                </div>
            </div>

            <!-- 제2부 암기 요약 원문 -->
            <h3 class="text-lg font-bold text-gray-900 mb-4">📖 제2부 — 서술형 답안 암기 요약 자료</h3>
            <div class="textbook-content">

                <h4>1. 한 줄 정의</h4>
                <table>
                    <thead><tr><th>토픽</th><th>한 줄 정의</th></tr></thead>
                    <tbody>
                        <tr><td><strong>선점형 스케줄링</strong></td><td>타이머 인터럽트로 실행 중인 프로세스의 CPU를 강제 회수할 수 있는 스케줄링 방식</td></tr>
                        <tr><td><strong>비선점형 스케줄링</strong></td><td>프로세스가 자발적으로 CPU를 반납할 때까지 점유를 보장하는 스케줄링 방식</td></tr>
                        <tr><td><strong>MLFQ</strong></td><td>프로세스의 CPU 사용 이력을 관찰하여 큐 간 동적 이동을 허용하는 적응형 다단계 스케줄링 (Corbató, 1962)</td></tr>
                        <tr><td><strong>에이징</strong></td><td>대기 시간 증가에 따라 우선순위를 점진적으로 상향하여 기아현상을 방지하는 기법</td></tr>
                    </tbody>
                </table>

                <h4>2. 핵심 키워드 맵</h4>
                <p><strong>선점/비선점 키워드</strong>: Timer Interrupt / Context Switching / Time Quantum / Convoy Effect / Race Condition</p>
                <p><strong>알고리즘 키워드</strong>: Round Robin / Multi-Level Queue / Feedback / CPU-Bound / I/O-Bound / Priority Boosting / Gaming 방지</p>
                <p><strong>기아/에이징 키워드</strong>: Starvation / Aging / HRN / vruntime / CFS / 공정성(Fairness)</p>

                <h4>3. 두문자어 암기법</h4>
                <ul>
                    <li><strong>비교 핵심 기준</strong>: <span class="highlight">"회응공실적대"</span> (회수방식-응답시간-공정성-실시간지원-적합환경-대표알고리즘)</li>
                    <li><strong>MLFQ 5대 규칙</strong>: <span class="highlight">"우동최하유"</span> (우선순위비교-동등시RR-최상위큐진입-하위이동(CPU)-유지(I/O))</li>
                    <li><strong>기아 발생 3원인</strong>: <span class="highlight">"우짧하"</span> (우선순위선점-짧은작업연속-하위큐고착)</li>
                    <li><strong>기아 해결 기법</strong>: <span class="highlight">"에부적"</span> (에이징-부스팅-적응적큐이동)</li>
                </ul>

                <h4>4. 골격 답안 구조</h4>
                <p><strong>2교시형 — 소문제별 구조</strong></p>
                <table>
                    <thead><tr><th>구분</th><th>핵심 내용</th><th>분량 비중</th></tr></thead>
                    <tbody>
                        <tr><td><strong>서론</strong></td><td>클라우드 환경에서 CPU 스케줄링의 중요성 → 3개 소문제 연결 구조 예고</td><td>10%</td></tr>
                        <tr><td><strong>소문제 1</strong></td><td>선점/비선점 정의 + 비교표(8~10개 기준) + Convoy Effect/Race Condition</td><td>25%</td></tr>
                        <tr><td><strong>소문제 2</strong></td><td>RR 동작(TQ 영향) + MLQ 큐 구성 + MLFQ 5규칙 + 진화 비교표</td><td>30%</td></tr>
                        <tr><td><strong>소문제 3</strong></td><td>기아 정의/원인 + 에이징 원리 + HRN 공식/수치 예시 + Priority Boosting</td><td>25%</td></tr>
                        <tr><td><strong>결론</strong></td><td>분류→진화→보완 통합 + CFS/클라우드 현대적 적용</td><td>10%</td></tr>
                    </tbody>
                </table>

                <h4>5. 필수 도식</h4>
                <p><strong>도식 1: 선점형 vs 비선점형 비교표</strong> (소문제 1) — [답안지에 10행 비교표로 표현]</p>
                <p><strong>도식 2: MLFQ 큐 구조도</strong> (소문제 2) — [답안지에 3단 큐 구조 + 이동 화살표로 표현]</p>
                <ul>
                    <li>Q0(최우선, RR q=8ms) → Q1(중간, RR q=16ms) → Q2(최하위, FCFS)</li>
                    <li>TQ 만료 시 ↓ 이동, I/O 요청 시 현재 큐 유지</li>
                </ul>
                <p><strong>도식 3: HRN 수치 예시</strong> (소문제 3) — [답안지에 3행 계산 테이블로 표현]</p>

                <h4>6. 차별화 포인트</h4>
                <ul>
                    <li>MLFQ의 <strong>5대 규칙</strong>을 Arpaci-Dusseau(OSTEP) 기준으로 정리하면 학술적 깊이를 보여줄 수 있다.</li>
                    <li>HRN 공식에 <strong>구체적 수치를 대입</strong>하여 계산하면 이해도를 직접적으로 증명할 수 있다.</li>
                    <li><strong>Linux CFS의 vruntime</strong>을 에이징의 현대적 구현으로 연결하면 실무 관점이 강화된다.</li>
                    <li>결론에서 <strong>Kubernetes Pod 스케줄러</strong>를 언급하면 클라우드 시대의 스케줄링 관점을 보여줄 수 있다.</li>
                </ul>

            </div><!-- textbook-content -->
        </div>
    </section>
    </main>
    <footer class="bg-white mt-12 py-8 border-t border-gray-200">
        <div class="max-w-6xl mx-auto px-4 text-center">
            <div class="flex flex-col md:flex-row justify-center items-center gap-2 md:gap-6 text-sm text-gray-600 mb-3 font-medium">
                <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-indigo-500"></span><span>박교익PE (132회 정보관리기술사, dr.code92@gmail.com)</span></div>
            </div>
            <p class="text-xs text-gray-400">Copyright &copy; KPC 정보관리기술사 ZIP-UP 심화반. All rights reserved.</p>
        </div>
    </footer>
    <div id="chat-sidebar" class="fixed top-0 right-0 h-full w-full sm:w-96 bg-white shadow-2xl z-50 closed flex flex-col border-l border-gray-200">
        <div class="bg-indigo-600 p-4 text-white flex justify-between items-center shadow-md"><div class="flex items-center gap-2"><span class="text-xl">🤖</span><span class="font-bold">AI 튜터에게 질문하기</span></div><button onclick="toggleChat()" class="hover:bg-indigo-700 p-1 rounded transition-colors">✕</button></div>
        <div id="chat-messages" class="flex-grow overflow-y-auto p-4 bg-gray-50 flex flex-col gap-3"><div class="chat-msg ai">안녕하세요! CPU 스케줄링, RR, MLQ, MLFQ, 에이징 등 학습 중 궁금한 점이 있다면 언제든 물어보세요.</div></div>
        <div class="p-4 bg-white border-t border-gray-200"><div class="flex gap-2"><input type="text" id="chat-input" placeholder="질문을 입력하세요..." class="flex-grow border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-sm" onkeypress="handleChatKey(event)"><button onclick="sendChatMessage()" class="bg-indigo-600 hover:bg-indigo-700 text-white p-2 rounded-lg transition-colors">📨</button></div></div>
    </div>
    <button onclick="toggleChat()" class="fixed bottom-6 right-6 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full p-4 shadow-lg z-40 transition-transform hover:scale-110 flex items-center gap-2 group"><span class="text-2xl">💬</span><span class="max-w-0 overflow-hidden group-hover:max-w-xs transition-all duration-300 whitespace-nowrap text-sm font-bold">AI 튜터</span></button>
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex justify-center items-center">
        <div class="bg-white rounded-lg p-6 w-full max-w-md mx-4 shadow-xl"><h3 class="text-lg font-bold mb-4">⚙️ API Key 설정</h3><p class="text-sm text-gray-600 mb-4">AI 기능을 사용하기 위해 Google Gemini API Key를 입력해주세요.<br><a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-indigo-600 hover:underline">키 발급받기 ↗</a></p><input type="password" id="api-key-input" placeholder="API Key 입력" class="w-full border border-gray-300 rounded-lg px-4 py-2 mb-4 focus:outline-none focus:ring-2 focus:ring-indigo-500"><div class="flex justify-end gap-2"><button onclick="toggleSettings()" class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg">취소</button><button onclick="saveApiKey()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">저장</button></div></div>
    </div>
<script>
var isMentorMode=new URLSearchParams(window.location.search).get('mentor')==='true';if(isMentorMode){document.getElementById('nav-script').classList.remove('hidden');}
var sections=isMentorMode?['overview','comparison','algorithms','starvation','textbook','script','quiz']:['overview','comparison','algorithms','starvation','textbook','quiz'];
function navTo(id){document.querySelectorAll('.nav-item').forEach(function(el){el.classList.remove('active','text-indigo-600');});document.getElementById('nav-'+id).classList.add('active','text-indigo-600');sections.forEach(function(s){document.getElementById(s).classList.add('hidden');});document.getElementById(id).classList.remove('hidden');window.scrollTo({top:0,behavior:'smooth'});}
function getApiKey(){var k=localStorage.getItem('gemini_api_key');if(!k){var u=new URLSearchParams(window.location.search);k=u.get('key');}return k;}
function toggleSettings(){document.getElementById('settings-modal').classList.toggle('hidden');}
function saveApiKey(){var k=document.getElementById('api-key-input').value.trim();if(k){localStorage.setItem('gemini_api_key',k);toggleSettings();alert('API Key가 저장되었습니다.');}else{alert('API Key를 입력해주세요.');}}
function toggleChat(){var s=document.getElementById('chat-sidebar');s.classList.toggle('closed');s.classList.toggle('open');}
function handleChatKey(e){if(e.key==='Enter')sendChatMessage();}
function sendChatMessage(){var input=document.getElementById('chat-input');var msg=input.value.trim();if(!msg)return;var box=document.getElementById('chat-messages');box.innerHTML+='<div class="chat-msg user">'+msg+'</div>';input.value='';var key=getApiKey();if(!key){box.innerHTML+='<div class="chat-msg ai">⚠️ API Key가 설정되지 않았습니다. 상단의 🔑 API 버튼을 눌러 설정해주세요.</div>';toggleSettings();return;}box.innerHTML+='<div id="typing-ind" class="chat-msg ai"><div class="typing-indicator"><span></span><span></span><span></span></div></div>';box.scrollTop=box.scrollHeight;fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key='+key,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({contents:[{parts:[{text:"당신은 정보관리기술사 시험 멘토입니다. 'CPU 스케줄링, RR, MLQ, MLFQ, 에이징' 관련 질문에 전문적이고 명쾌하게 답변해주세요. 300자 이내로 핵심만 요약. 질문: "+msg}]}]})}).then(function(r){return r.json();}).then(function(d){var el=document.getElementById('typing-ind');if(el)el.remove();var t=d.candidates[0].content.parts[0].text;if(typeof marked!=='undefined'){box.innerHTML+='<div class="chat-msg ai">'+marked.parse(t)+'</div>';}else{box.innerHTML+='<div class="chat-msg ai">'+t+'</div>';}box.scrollTop=box.scrollHeight;}).catch(function(e){var el=document.getElementById('typing-ind');if(el)el.remove();box.innerHTML+='<div class="chat-msg ai">⚠️ 오류: '+e.message+'</div>';});}
var currentQuizData=null;var quizTypeHistory=[];
var quizTopics=[{category:"선점형/비선점형",keywords:"Timer Interrupt, Context Switching, Convoy Effect, Race Condition, 강제회수, 자발적반납"},{category:"RR 알고리즘",keywords:"Round Robin, Time Quantum, 공정성, CPU Burst, Processor Sharing, 문맥교환"},{category:"MLQ 알고리즘",keywords:"Multi-Level Queue, 고정큐, 큐간이동불가, 시스템프로세스, 대화형, 배치"},{category:"MLFQ 알고리즘",keywords:"Feedback Queue, 동적분류, CPU-Bound, I/O-Bound, 5대규칙, Corbato"},{category:"기아현상",keywords:"Starvation, 무한대기, 우선순위, SJF, 하위큐고착, 공정성"},{category:"에이징과 부스팅",keywords:"Aging, Priority Boosting, HRN, vruntime, CFS, Gaming방지"}];
function generateQuiz(){var key=getApiKey();if(!key){alert('API Key를 먼저 설정해주세요.');toggleSettings();return;}document.getElementById('quiz-loading').classList.remove('hidden');document.getElementById('quiz-container').classList.add('hidden');document.getElementById('quiz-placeholder').classList.add('hidden');document.getElementById('quiz-feedback').classList.add('hidden');var isMC;var recent=quizTypeHistory.slice(-2);if(recent.length>=2&&recent[0]===recent[1]){isMC=!recent[1];}else{isMC=Math.random()>0.5;}quizTypeHistory.push(isMC);var sel=quizTopics[Math.floor(Math.random()*quizTopics.length)];var prompt;if(isMC){prompt="다음 카테고리에 대한 객관식 퀴즈 1문제를 만드세요.\n카테고리: "+sel.category+"\n관련 키워드: "+sel.keywords+"\n규칙: 반드시 위 카테고리와 키워드에 직접 관련된 문제를 출제하세요.\nJSON형식: {\"type\":\"mc\",\"question\":\"문제\",\"options\":[\"A\",\"B\",\"C\",\"D\"],\"correctIndex\":0,\"explanation\":\"해설\"}";}else{prompt="다음 카테고리에 대한 단답형 퀴즈 1문제를 만드세요.\n카테고리: "+sel.category+"\n관련 키워드: "+sel.keywords+"\n규칙: 반드시 위 카테고리와 키워드에 직접 관련된 문제를 출제하세요.\nJSON형식: {\"type\":\"short\",\"question\":\"문제\",\"correctAnswer\":\"정답\",\"explanation\":\"해설\"}";}fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key='+key,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({contents:[{parts:[{text:prompt}]}],generationConfig:{responseMimeType:"application/json"}})}).then(function(r){return r.json();}).then(function(d){document.getElementById('quiz-loading').classList.add('hidden');var t=d.candidates[0].content.parts[0].text;t=t.replace(/```json\s*/gi,"").replace(/```\s*/g,"").trim();var depth=0,start=-1,end=-1;for(var i=0;i<t.length;i++){if(t[i]==='{'){if(depth===0)start=i;depth++;}else if(t[i]==='}'){depth--;if(depth===0&&start!==-1){end=i;break;}}}if(start===-1||end===-1)throw new Error("No JSON found");t=t.substring(start,end+1);t=t.replace(/[\x00-\x1F\x7F]/g,function(c){return c==='\n'||c==='\r'||c==='\t'?' ':'';});currentQuizData=JSON.parse(t);renderQuiz();}).catch(function(e){document.getElementById('quiz-loading').classList.add('hidden');document.getElementById('quiz-placeholder').classList.remove('hidden');alert('퀴즈 생성 오류: '+e.message);});}
function renderQuiz(){if(!currentQuizData)return;var c=document.getElementById('quiz-container');c.classList.remove('hidden');document.getElementById('quiz-feedback').classList.add('hidden');var badge=document.getElementById('quiz-type-badge');document.getElementById('quiz-question').textContent=currentQuizData.question;if(currentQuizData.type==='mc'){badge.textContent='객관식';badge.className='bg-indigo-100 text-indigo-800 text-xs font-bold px-2 py-1 rounded whitespace-nowrap mt-1';var opts=document.getElementById('quiz-options');opts.innerHTML='';opts.classList.remove('hidden');document.getElementById('quiz-input-area').classList.add('hidden');currentQuizData.options.forEach(function(o,i){opts.innerHTML+='<button onclick="checkMultipleChoice('+i+')" class="w-full text-left p-3 rounded-lg border border-gray-200 hover:border-indigo-400 hover:bg-indigo-50 transition-colors text-sm font-medium">'+String.fromCharCode(65+i)+'. '+o+'</button>';});}else{badge.textContent='단답형';badge.className='bg-green-100 text-green-800 text-xs font-bold px-2 py-1 rounded whitespace-nowrap mt-1';document.getElementById('quiz-options').classList.add('hidden');document.getElementById('quiz-options').innerHTML='';document.getElementById('quiz-input-area').classList.remove('hidden');document.getElementById('quiz-answer-input').value='';}}
function checkMultipleChoice(idx){var fb=document.getElementById('quiz-feedback');fb.classList.remove('hidden');if(idx===currentQuizData.correctIndex){fb.className='bg-green-50 p-5 rounded-lg border-l-4 border-green-500';fb.innerHTML='<p class="font-bold text-green-800 mb-1">✅ 정답!</p><p class="text-sm text-green-700">'+currentQuizData.explanation+'</p>';}else{fb.className='bg-red-50 p-5 rounded-lg border-l-4 border-red-500';fb.innerHTML='<p class="font-bold text-red-800 mb-1">❌ 오답</p><p class="text-sm text-red-700 mb-1">정답: '+String.fromCharCode(65+currentQuizData.correctIndex)+'. '+currentQuizData.options[currentQuizData.correctIndex]+'</p><p class="text-sm text-red-700">'+currentQuizData.explanation+'</p>';}}
function checkShortAnswer(){var ans=document.getElementById('quiz-answer-input').value.trim();if(!ans){alert('답을 입력해주세요.');return;}var key=getApiKey();if(!key){localGrade(ans);return;}var btn=document.querySelector('#quiz-input-area button');btn.textContent='채점 중...';btn.disabled=true;var gp="당신은 정보관리기술사 시험 채점관입니다. 아래 문제에 대해 사용자의 답안이 정답으로 인정될 수 있는지 판정하세요.\n\n문제: "+currentQuizData.question+"\n모범 정답: "+currentQuizData.correctAnswer+"\n사용자 답안: "+ans+"\n\n판정 기준:\n- 핵심 의미가 동일하면 정답\n- 약어/풀네임 모두 인정\n- 영어/한글 혼용 인정\n- 띄어쓰기/조사 차이는 무시\n- 의미가 명확히 다르면 오답\n\nOutput JSON: {\"correct\":true/false,\"reason\":\"판정 이유\"}";fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key='+key,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({contents:[{parts:[{text:gp}]}],generationConfig:{responseMimeType:"application/json"}})}).then(function(r){return r.json();}).then(function(d){btn.textContent='제출';btn.disabled=false;var t=d.candidates[0].content.parts[0].text;t=t.replace(/```json\s*/gi,"").replace(/```\s*/g,"").trim();var depth2=0,s2=-1,e2=-1;for(var i=0;i<t.length;i++){if(t[i]==='{'){if(depth2===0)s2=i;depth2++;}else if(t[i]==='}'){depth2--;if(depth2===0&&s2!==-1){e2=i;break;}}}t=t.substring(s2,e2+1);t=t.replace(/[\x00-\x1F\x7F]/g,function(c){return c==='\n'||c==='\r'||c==='\t'?' ':'';});var r2=JSON.parse(t);showFeedback(r2.correct,r2.reason);}).catch(function(){btn.textContent='제출';btn.disabled=false;localGrade(ans);});}
function localGrade(ans){var ca=currentQuizData.correctAnswer.replace(/\s/g,'').toLowerCase();var ua=ans.replace(/\s/g,'').toLowerCase();var ok=ca===ua||ca.includes(ua)||ua.includes(ca);showFeedback(ok,'로컬 채점 결과');}
function showFeedback(correct,reason){var fb=document.getElementById('quiz-feedback');fb.classList.remove('hidden');if(correct){fb.className='bg-green-50 p-5 rounded-lg border-l-4 border-green-500';fb.innerHTML='<p class="font-bold text-green-800 mb-1">✅ 정답!</p><p class="text-sm text-green-700 mb-1">'+reason+'</p><p class="text-sm text-green-700">모범 정답: '+currentQuizData.correctAnswer+'</p><p class="text-sm text-green-700">'+currentQuizData.explanation+'</p>';}else{fb.className='bg-red-50 p-5 rounded-lg border-l-4 border-red-500';fb.innerHTML='<p class="font-bold text-red-800 mb-1">❌ 오답</p><p class="text-sm text-red-700 mb-1">'+reason+'</p><p class="text-sm text-red-700">모범 정답: '+currentQuizData.correctAnswer+'</p><p class="text-sm text-red-700">'+currentQuizData.explanation+'</p>';}}
function toggleStrategy(el){var d=el.querySelector('.strategy-detail');var s=el.querySelector('.strategy-summary');if(d.classList.contains('hidden')){document.querySelectorAll('.strategy-detail').forEach(function(x){x.classList.add('hidden');});document.querySelectorAll('.strategy-summary').forEach(function(x){x.classList.remove('hidden');});d.classList.remove('hidden');s.classList.add('hidden');}else{d.classList.add('hidden');s.classList.remove('hidden');}}
var algoDetails={
'rr':{title:'RR (Round Robin)',colorClass:'border-blue-500 bg-blue-50',content:'<h4 class="font-bold text-blue-800 mb-2">동작: 동일 Time Quantum으로 순환 할당</h4><p class="text-sm text-gray-700 mb-2">모든 프로세스에 동일한 시간(q)을 부여, 큐를 순환하며 CPU 할당. q 만료 시 Ready Queue 맨 뒤로 이동.</p><p class="text-sm text-gray-700 mb-2"><strong>최적 q:</strong> CPU Burst의 80%가 q 이내에 완료 (일반적 10~100ms)</p><p class="text-sm text-gray-700"><strong>장점:</strong> 공정성 보장, 기아 없음 / <strong>단점:</strong> CPU-Bound vs I/O-Bound 구분 불가</p>'},
'mlq':{title:'MLQ (Multi-Level Queue)',colorClass:'border-green-500 bg-green-50',content:'<h4 class="font-bold text-green-800 mb-2">동작: 다수 고정 큐, 유형별 영구 배정</h4><p class="text-sm text-gray-700 mb-2">프로세스를 속성별로 고정 큐에 배정. Q1 시스템(Priority) / Q2 대화형(RR) / Q3 배치(FCFS).</p><p class="text-sm text-gray-700 mb-2"><strong>큐 간 이동 불가</strong> → 유연성 부족</p><p class="text-sm text-gray-700"><strong>장점:</strong> 유형별 최적 정책 / <strong>단점:</strong> 하위 큐 기아 발생 가능</p>'},
'mlfq':{title:'MLFQ (Multi-Level Feedback Queue)',colorClass:'border-purple-500 bg-purple-50',content:'<h4 class="font-bold text-purple-800 mb-2">동작: 피드백 기반 동적 큐 이동</h4><p class="text-sm text-gray-700 mb-2">5대 규칙 <strong>"우동최하유"</strong>: 우선순위 비교→동등시 RR→최상위 큐 진입→TQ만료 시 하위 이동→I/O시 유지</p><p class="text-sm text-gray-700 mb-2">프로세스의 CPU 사용 패턴을 관찰하여 CPU-Bound/I/O-Bound 자동 분류.</p><p class="text-sm text-gray-700"><strong>장점:</strong> 적응적 분류, 현대 OS 표준 / <strong>단점:</strong> 매개변수 복잡, Gaming 문제</p>'}
};
function updateAlgoDetail(key){document.querySelectorAll('.tech-block').forEach(function(el){el.classList.remove('selected');});document.getElementById('block-'+key).classList.add('selected');var d=algoDetails[key];document.getElementById('algo-detail-content').innerHTML='<div class="p-5 rounded-lg border-l-4 '+d.colorClass+' animate-fade-in"><h3 class="text-lg font-bold text-gray-900 mb-3">'+d.title+'</h3>'+d.content+'</div>';}
window.addEventListener('load',function(){var k=getApiKey();if(k){document.getElementById('api-key-input').value=k;}});
</script>
</body>
</html>
