<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>트랜잭션 격리 수준(Isolation Level)과 Dirty Read — KPC ZIP-UP</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
<style>
body{font-family:'Noto Sans KR',sans-serif}
.def-box{background:linear-gradient(135deg,#eef2ff 0%,#e0e7ff 100%);border-left:4px solid #4f46e5;border-radius:8px;padding:1.25rem;margin-bottom:1rem}
.def-box p{color:#312e81;font-weight:500;margin:0;line-height:1.8}
.insight-box{background-color:#fffbeb;border:1px solid #fde68a;border-radius:8px;padding:1rem;margin:1rem 0}
.insight-box::before{content:'💡';margin-right:.5rem}
.textbook-content h3{font-size:1.25rem;font-weight:700;color:#1e3a8a;margin-top:1.5rem;margin-bottom:.75rem;border-left:4px solid #4f46e5;padding-left:.75rem}
.textbook-content h4{font-size:1.1rem;font-weight:600;color:#374151;margin-top:1rem;margin-bottom:.5rem}
.textbook-content p{margin-bottom:1rem;line-height:1.8;color:#4b5563}
.textbook-content ul{list-style-type:disc;padding-left:1.5rem;margin-bottom:1rem;color:#4b5563}
.textbook-content li{margin-bottom:.5rem;line-height:1.7}
.textbook-content table{width:100%;border-collapse:collapse;margin-bottom:1.5rem;font-size:.95rem}
.textbook-content th,.textbook-content td{border:1px solid #e5e7eb;padding:.75rem;text-align:left}
.textbook-content th{background-color:#f9fafb;font-weight:600;color:#1f2937}
.textbook-content .highlight{background-color:#eef2ff;color:#4338ca;font-weight:600;padding:0 4px;border-radius:4px}
.textbook-content pre{background-color:#f8fafc;border:1px solid #e2e8f0;border-radius:8px;padding:1rem;overflow-x:auto;margin-bottom:1rem;font-size:.85rem;line-height:1.6}
.textbook-content code{font-family:'Courier New',monospace}
.tech-block{transition:all .3s ease;cursor:pointer}
.tech-block:hover{transform:translateY(-2px);box-shadow:0 4px 6px -1px rgba(0,0,0,.1)}
.tech-block.selected{ring:2px;ring-color:#4f46e5;background-color:#eef2ff;border-color:#4f46e5}
.nav-item.active{border-bottom:2px solid #4f46e5;color:#4f46e5;font-weight:700}
.chat-msg{border-radius:12px;padding:10px 14px;margin-bottom:10px;max-width:85%;font-size:.95rem}
.chat-msg.user{background-color:#4f46e5;color:#fff;align-self:flex-end;margin-left:auto}
.chat-msg.ai{background-color:#f3f4f6;color:#1f2937;align-self:flex-start;border:1px solid #e5e7eb}
#chat-sidebar{transition:transform .3s ease-in-out}
#chat-sidebar.closed{transform:translateX(100%)}
#chat-sidebar.open{transform:translateX(0)}
.typing-indicator span{display:inline-block;width:6px;height:6px;background-color:#4f46e5;border-radius:50%;animation:typing 1.4s infinite ease-in-out both;margin:0 2px}
.typing-indicator span:nth-child(1){animation-delay:-.32s}
.typing-indicator span:nth-child(2){animation-delay:-.16s}
@keyframes typing{0%,80%,100%{transform:scale(0)}40%{transform:scale(1)}}
.chart-container{position:relative;width:100%;max-width:600px;margin-left:auto;margin-right:auto;height:350px;max-height:400px}
.no-scrollbar::-webkit-scrollbar{display:none}
.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.animate-fade-in{animation:fadeIn .4s ease-out forwards}
.strategy-card{cursor:pointer;transition:all .3s ease}
.strategy-card:hover{transform:translateY(-2px);box-shadow:0 4px 6px -1px rgba(0,0,0,.1)}
</style>
</head>
<body class="bg-stone-100 min-h-screen flex flex-col overflow-x-hidden">
<header class="bg-white shadow-sm sticky top-0 z-40">
<div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8">
<div class="flex justify-between items-center pt-3 pb-1">
<div class="flex flex-col justify-center min-w-0">
<span class="text-[10px] sm:text-xs text-indigo-600 font-bold uppercase tracking-wider leading-tight">KPC 정보관리기술사 ZIP-UP 심화반</span>
<div class="flex items-center gap-2">
<span class="text-lg sm:text-xl font-bold text-gray-900 tracking-tight truncate">트랜잭션 격리 수준(Isolation Level)과 Dirty Read</span>
<span class="text-[10px] sm:text-xs bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded-full font-bold flex-shrink-0">2026</span>
</div>
</div>
</div>
<nav class="flex space-x-1 sm:space-x-4 overflow-x-auto no-scrollbar pb-1 items-center">
<button onclick="navTo('overview')" id="nav-overview" class="nav-item active px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">개요 및 개념</button>
<button onclick="navTo('levels')" id="nav-levels" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">4단계 격리 수준</button>
<button onclick="navTo('anomaly')" id="nav-anomaly" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">이상 현상·성능</button>
<button onclick="navTo('textbook')" id="nav-textbook" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">원문 학습</button>
<button onclick="navTo('script')" id="nav-script" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap hidden">🎬 강의 스크립트</button>
<button onclick="navTo('quiz')" id="nav-quiz" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">퀴즈 &amp; 암기</button>
<span class="w-px h-4 bg-gray-300 flex-shrink-0"></span>
<button onclick="toggleSettings()" class="flex items-center gap-1 px-2.5 py-1 rounded-full text-xs font-medium text-indigo-600 hover:bg-indigo-50 border border-indigo-200 hover:border-indigo-400 transition-all whitespace-nowrap flex-shrink-0" title="API Key 설정">🔑 API</button>
</nav>
</div>
</header>
<main class="flex-grow max-w-5xl w-full mx-auto px-4 sm:px-6 lg:px-8 py-8 space-y-12 pb-24">

<div id="overview">
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 border-l-4 border-indigo-500">
<h2 class="text-xl font-bold text-gray-900 mb-4">📘 트랜잭션 격리 수준(Isolation Level)의 정의</h2>
<div class="def-box">
<p><strong>트랜잭션 격리 수준(Isolation Level)</strong>이란, ANSI SQL-92에서 정의한 동시 실행 트랜잭션 간 간섭 정도를 4단계(Read Uncommitted, Read Committed, Repeatable Read, Serializable)로 구분하여, <strong>동시성(Concurrency)과 데이터 정합성(Consistency) 간의 트레이드오프</strong>를 조정하는 메커니즘이다.</p>
</div>
<p class="text-gray-600 leading-relaxed mt-4">쉽게 말하면, 은행에서 수천 명이 동시에 이체할 때 "어디까지 남의 작업 중간 결과를 볼 수 있게 할 것인가?"를 결정하는 규칙입니다. 완벽하게 격리하면 데이터는 안전하지만 처리 속도가 느려지고, 격리를 느슨하게 하면 빠르지만 <strong>Dirty Read</strong> 같은 이상 현상이 발생할 수 있습니다. 이 트레이드오프를 4단계로 나눈 것이 격리 수준입니다.</p>
</div>

<!-- 배경·맥락 카드 -->
<div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
<div class="bg-white rounded-xl shadow-sm p-5 border-t-4 border-indigo-400">
<h3 class="text-sm font-bold text-indigo-700 mb-2">🔑 ACID 속성 중 격리성</h3>
<p class="text-gray-600 text-sm leading-relaxed">Jim Gray(1981)가 체계화한 트랜잭션의 4가지 필수 속성 <strong>"원일격지"</strong>(원자성·일관성·격리성·지속성) 중 격리성(Isolation)은 동시성 제어와 직접 관련된다. 격리 수준은 이 격리성의 강도를 단계별로 조절하는 파라미터이다.</p>
</div>
<div class="bg-white rounded-xl shadow-sm p-5 border-t-4 border-green-400">
<h3 class="text-sm font-bold text-green-700 mb-2">⚖️ 동시성 vs 정합성 트레이드오프</h3>
<p class="text-gray-600 text-sm leading-relaxed">Serializable 수준은 데이터 정합성을 보장하지만 TPS가 50~70%로 저하된다. Read Committed는 약 30~50%의 처리량 향상을 제공하지만 Non-Repeatable Read가 발생할 수 있다. 애플리케이션 요구사항에 맞는 적절한 수준 선택이 핵심이다.</p>
</div>
<div class="bg-white rounded-xl shadow-sm p-5 border-t-4 border-amber-400">
<h3 class="text-sm font-bold text-amber-700 mb-2">📊 동시성 제어 기법</h3>
<p class="text-gray-600 text-sm leading-relaxed"><strong>Lock 기반(2PL)</strong>: 공유 잠금(S-Lock)과 배타 잠금(X-Lock)을 사용. 확장→축소 단계를 거쳐 직렬 가능성 보장. SQL Server, DB2 등에서 사용.<br><strong>MVCC</strong>: 데이터의 여러 버전을 유지하여 읽기-쓰기 비차단(Non-blocking). PostgreSQL, Oracle, MySQL InnoDB에서 사용.</p>
</div>
<div class="bg-white rounded-xl shadow-sm p-5 border-t-4 border-purple-400">
<h3 class="text-sm font-bold text-purple-700 mb-2">🎯 시험 출제 포인트</h3>
<p class="text-gray-600 text-sm leading-relaxed">DB 영역 가장 빈출 토픽 중 하나. 1교시: "ACID 속성", "격리 수준 4단계", "Dirty Read 정의와 방지". 2교시: "동시성 제어 기법 비교", "MVCC 동작 원리"와 결합 출제. 답안의 핵심 도식은 이상 현상 매트릭스 + Dirty Read 타이밍 다이어그램.</p>
</div>
</div>

<!-- 차트: 격리 수준별 TPS 비교 -->
<div class="bg-white rounded-xl shadow-sm p-6 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">📊 격리 수준별 상대적 성능 비교 (TPC-C 기준)</h3>
<div class="chart-container"><canvas id="tpsChart"></canvas></div>
<p class="text-xs text-gray-400 mt-3 text-center">* TPC-C 벤치마크(100 Warehouse, 10 Terminal) 환경의 상대적 비교값입니다.</p>
</div>
<script>
document.addEventListener('DOMContentLoaded',function(){
var ctx=document.getElementById('tpsChart');
if(ctx){new Chart(ctx,{type:'bar',data:{labels:['Read Uncommitted','Read Committed','Repeatable Read','Serializable'],datasets:[{label:'상대 TPS (%)',data:[100,90,77,60],backgroundColor:['rgba(239,68,68,0.7)','rgba(59,130,246,0.7)','rgba(34,197,94,0.7)','rgba(168,85,247,0.7)'],borderColor:['#ef4444','#3b82f6','#22c55e','#a855f7'],borderWidth:2},{label:'잠금 대기 비율 (%)',data:[1,7,15,30],backgroundColor:['rgba(239,68,68,0.2)','rgba(59,130,246,0.2)','rgba(34,197,94,0.2)','rgba(168,85,247,0.2)'],borderColor:['#ef4444','#3b82f6','#22c55e','#a855f7'],borderWidth:2,borderDash:[5,5]}]},options:{responsive:true,maintainAspectRatio:false,scales:{y:{beginAtZero:true,max:110,title:{display:true,text:'비율 (%)'}},x:{title:{display:true,text:'격리 수준'}}},plugins:{legend:{position:'top'}}}});}
});
</script>
</div>

<div id="levels" class="hidden">
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<h2 class="text-xl font-bold text-gray-900 mb-2">🔒 ANSI SQL-92 4단계 격리 수준</h2>
<p class="text-gray-500 text-sm mb-6">각 격리 수준을 클릭하면 상세 동작 방식을 확인할 수 있습니다.</p>
<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3 mb-6">
<div id="block-ru" class="tech-block border-2 border-red-200 rounded-xl p-4 bg-white" onclick="updateLevelDetail('ru')">
<div class="flex items-center gap-2 mb-2"><span class="w-8 h-8 rounded-full bg-red-100 text-red-600 flex items-center justify-center font-bold text-sm">L0</span><span class="text-sm font-bold text-gray-900">Read Uncommitted</span></div>
<p class="text-xs text-gray-500">커밋되지 않은 읽기</p>
<div class="flex gap-1 mt-2"><span class="px-1.5 py-0.5 bg-red-100 text-red-700 rounded text-[10px] font-medium">Dirty ⭕</span><span class="px-1.5 py-0.5 bg-red-100 text-red-700 rounded text-[10px] font-medium">NR ⭕</span><span class="px-1.5 py-0.5 bg-red-100 text-red-700 rounded text-[10px] font-medium">Phantom ⭕</span></div>
</div>
<div id="block-rc" class="tech-block border-2 border-blue-200 rounded-xl p-4 bg-white" onclick="updateLevelDetail('rc')">
<div class="flex items-center gap-2 mb-2"><span class="w-8 h-8 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center font-bold text-sm">L1</span><span class="text-sm font-bold text-gray-900">Read Committed</span></div>
<p class="text-xs text-gray-500">커밋된 읽기</p>
<div class="flex gap-1 mt-2"><span class="px-1.5 py-0.5 bg-green-100 text-green-700 rounded text-[10px] font-medium">Dirty ❌</span><span class="px-1.5 py-0.5 bg-red-100 text-red-700 rounded text-[10px] font-medium">NR ⭕</span><span class="px-1.5 py-0.5 bg-red-100 text-red-700 rounded text-[10px] font-medium">Phantom ⭕</span></div>
</div>
<div id="block-rr" class="tech-block border-2 border-green-200 rounded-xl p-4 bg-white" onclick="updateLevelDetail('rr')">
<div class="flex items-center gap-2 mb-2"><span class="w-8 h-8 rounded-full bg-green-100 text-green-600 flex items-center justify-center font-bold text-sm">L2</span><span class="text-sm font-bold text-gray-900">Repeatable Read</span></div>
<p class="text-xs text-gray-500">반복 가능한 읽기</p>
<div class="flex gap-1 mt-2"><span class="px-1.5 py-0.5 bg-green-100 text-green-700 rounded text-[10px] font-medium">Dirty ❌</span><span class="px-1.5 py-0.5 bg-green-100 text-green-700 rounded text-[10px] font-medium">NR ❌</span><span class="px-1.5 py-0.5 bg-red-100 text-red-700 rounded text-[10px] font-medium">Phantom ⭕</span></div>
</div>
<div id="block-sr" class="tech-block border-2 border-purple-200 rounded-xl p-4 bg-white" onclick="updateLevelDetail('sr')">
<div class="flex items-center gap-2 mb-2"><span class="w-8 h-8 rounded-full bg-purple-100 text-purple-600 flex items-center justify-center font-bold text-sm">L3</span><span class="text-sm font-bold text-gray-900">Serializable</span></div>
<p class="text-xs text-gray-500">직렬화 가능</p>
<div class="flex gap-1 mt-2"><span class="px-1.5 py-0.5 bg-green-100 text-green-700 rounded text-[10px] font-medium">Dirty ❌</span><span class="px-1.5 py-0.5 bg-green-100 text-green-700 rounded text-[10px] font-medium">NR ❌</span><span class="px-1.5 py-0.5 bg-green-100 text-green-700 rounded text-[10px] font-medium">Phantom ❌</span></div>
</div>
</div>
<div id="level-detail-content">
<div class="bg-gray-50 rounded-xl p-8 text-center text-gray-400">
<p class="text-lg">👆 위의 격리 수준 카드를 클릭하면 상세 정보가 표시됩니다.</p>
</div>
</div>
</div>

<!-- ACID 속성 표 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">🧱 ACID 속성과 보장 메커니즘</h3>
<div class="overflow-x-auto">
<table class="w-full border-collapse text-sm">
<thead><tr class="bg-indigo-50">
<th class="border border-gray-200 px-4 py-3 text-left font-bold text-indigo-800">속성</th>
<th class="border border-gray-200 px-4 py-3 text-left font-bold text-indigo-800">정의</th>
<th class="border border-gray-200 px-4 py-3 text-left font-bold text-indigo-800">보장 메커니즘</th>
</tr></thead>
<tbody>
<tr><td class="border border-gray-200 px-4 py-3 font-medium text-gray-900">원자성(Atomicity)</td><td class="border border-gray-200 px-4 py-3 text-gray-700">모든 연산이 완전히 수행되거나 전혀 수행되지 않음</td><td class="border border-gray-200 px-4 py-3 text-gray-700">Undo/Redo 로그, WAL</td></tr>
<tr class="bg-gray-50"><td class="border border-gray-200 px-4 py-3 font-medium text-gray-900">일관성(Consistency)</td><td class="border border-gray-200 px-4 py-3 text-gray-700">실행 전후로 일관된 상태 유지</td><td class="border border-gray-200 px-4 py-3 text-gray-700">무결성 제약조건, 트리거</td></tr>
<tr><td class="border border-gray-200 px-4 py-3 font-medium text-indigo-700 bg-indigo-50">격리성(Isolation) ★</td><td class="border border-gray-200 px-4 py-3 text-gray-700 bg-indigo-50">동시 실행 트랜잭션이 서로 간섭하지 않음</td><td class="border border-gray-200 px-4 py-3 text-gray-700 bg-indigo-50">격리 수준, Lock, MVCC</td></tr>
<tr class="bg-gray-50"><td class="border border-gray-200 px-4 py-3 font-medium text-gray-900">지속성(Durability)</td><td class="border border-gray-200 px-4 py-3 text-gray-700">COMMIT 결과는 영구 반영</td><td class="border border-gray-200 px-4 py-3 text-gray-700">WAL, 체크포인트, 이중화</td></tr>
</tbody></table>
</div>
</div>

<!-- 잠금 유형 비교 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">🔐 잠금 기반 동시성 제어 (2PL)</h3>
<div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
<div class="bg-blue-50 rounded-xl p-4 border border-blue-200">
<h4 class="text-sm font-bold text-blue-800 mb-2">공유 잠금 (S-Lock)</h4>
<p class="text-sm text-blue-700">읽기(Read) 시 설정. 다른 트랜잭션의 읽기 허용. S-Lock과 호환.</p>
</div>
<div class="bg-red-50 rounded-xl p-4 border border-red-200">
<h4 class="text-sm font-bold text-red-800 mb-2">배타 잠금 (X-Lock)</h4>
<p class="text-sm text-red-700">쓰기(Write) 시 설정. 다른 모든 잠금 차단. 모든 잠금과 비호환.</p>
</div>
</div>
<!-- 2PL 흐름 시각화 -->
<div class="bg-gray-50 rounded-xl p-5">
<h4 class="text-sm font-bold text-gray-700 mb-3">2단계 잠금 프로토콜 (2PL) 흐름</h4>
<div class="flex items-center justify-center gap-2 flex-wrap">
<div class="bg-green-100 border border-green-300 rounded-lg px-4 py-3 text-center">
<p class="text-xs text-green-800 font-bold">확장 단계</p>
<p class="text-[10px] text-green-600">Growing Phase</p>
<p class="text-xs text-green-700 mt-1">잠금 획득만 가능</p>
</div>
<span class="text-2xl text-gray-400">→</span>
<div class="bg-indigo-100 border border-indigo-300 rounded-lg px-4 py-3 text-center">
<p class="text-xs text-indigo-800 font-bold">잠금 포인트</p>
<p class="text-[10px] text-indigo-600">Lock Point</p>
<p class="text-xs text-indigo-700 mt-1">최대 잠금 보유</p>
</div>
<span class="text-2xl text-gray-400">→</span>
<div class="bg-amber-100 border border-amber-300 rounded-lg px-4 py-3 text-center">
<p class="text-xs text-amber-800 font-bold">축소 단계</p>
<p class="text-[10px] text-amber-600">Shrinking Phase</p>
<p class="text-xs text-amber-700 mt-1">잠금 해제만 가능</p>
</div>
</div>
<div class="insight-box mt-3"><p class="text-sm text-gray-700">확장 → 축소의 순서를 지키면 <strong>직렬 가능성(Serializability)</strong>이 보장된다 (Eswaran, 1976)</p></div>
</div>
</div>
</div>

<div id="anomaly" class="hidden">
<!-- 이상 현상 매트릭스 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<h2 class="text-xl font-bold text-gray-900 mb-4">⚠️ 읽기 이상 현상 매트릭스</h2>

<!-- 3가지 이상 현상 정의 -->
<div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
<div class="bg-red-50 rounded-xl p-4 border border-red-200">
<h4 class="text-sm font-bold text-red-800 mb-2">💀 Dirty Read</h4>
<p class="text-xs text-red-700 leading-relaxed"><strong>커밋되지 않은</strong> 다른 트랜잭션의 수정 데이터를 읽는 현상. 쓰기 중인 데이터에 잠금 없이 접근할 때 발생.</p>
</div>
<div class="bg-amber-50 rounded-xl p-4 border border-amber-200">
<h4 class="text-sm font-bold text-amber-800 mb-2">🔄 Non-Repeatable Read</h4>
<p class="text-xs text-amber-700 leading-relaxed">같은 데이터를 두 번 읽었을 때 <strong>값이 다른</strong> 현상. UPDATE로 인한. 읽기 잠금이 조기 해제되어 중간에 다른 트랜잭션이 수정.</p>
</div>
<div class="bg-purple-50 rounded-xl p-4 border border-purple-200">
<h4 class="text-sm font-bold text-purple-800 mb-2">👻 Phantom Read</h4>
<p class="text-xs text-purple-700 leading-relaxed">범위 검색 시 이전에 없던 <strong>새로운 행</strong>이 나타나는 현상. INSERT로 인한. 범위 잠금이 없어 새 행 삽입 가능.</p>
</div>
</div>

<!-- 매트릭스 표 -->
<div class="overflow-x-auto">
<table class="w-full border-collapse text-sm">
<thead><tr class="bg-indigo-50">
<th class="border border-gray-200 px-4 py-3 text-left font-bold text-indigo-800">격리 수준</th>
<th class="border border-gray-200 px-4 py-3 text-center font-bold text-red-700">Dirty Read</th>
<th class="border border-gray-200 px-4 py-3 text-center font-bold text-amber-700">Non-Repeatable Read</th>
<th class="border border-gray-200 px-4 py-3 text-center font-bold text-purple-700">Phantom Read</th>
<th class="border border-gray-200 px-4 py-3 text-center font-bold text-indigo-700">동시성</th>
</tr></thead>
<tbody>
<tr class="bg-red-50"><td class="border border-gray-200 px-4 py-3 font-medium">Read Uncommitted</td><td class="border border-gray-200 px-4 py-3 text-center text-red-600 font-bold">⭕ 발생</td><td class="border border-gray-200 px-4 py-3 text-center text-red-600 font-bold">⭕ 발생</td><td class="border border-gray-200 px-4 py-3 text-center text-red-600 font-bold">⭕ 발생</td><td class="border border-gray-200 px-4 py-3 text-center font-bold text-red-700">최고</td></tr>
<tr><td class="border border-gray-200 px-4 py-3 font-medium">Read Committed</td><td class="border border-gray-200 px-4 py-3 text-center text-green-600 font-bold">❌ 방지</td><td class="border border-gray-200 px-4 py-3 text-center text-red-600 font-bold">⭕ 발생</td><td class="border border-gray-200 px-4 py-3 text-center text-red-600 font-bold">⭕ 발생</td><td class="border border-gray-200 px-4 py-3 text-center font-bold text-blue-700">높음</td></tr>
<tr class="bg-green-50"><td class="border border-gray-200 px-4 py-3 font-medium">Repeatable Read</td><td class="border border-gray-200 px-4 py-3 text-center text-green-600 font-bold">❌ 방지</td><td class="border border-gray-200 px-4 py-3 text-center text-green-600 font-bold">❌ 방지</td><td class="border border-gray-200 px-4 py-3 text-center text-red-600 font-bold">⭕ 발생</td><td class="border border-gray-200 px-4 py-3 text-center font-bold text-green-700">보통</td></tr>
<tr class="bg-purple-50"><td class="border border-gray-200 px-4 py-3 font-medium">Serializable</td><td class="border border-gray-200 px-4 py-3 text-center text-green-600 font-bold">❌ 방지</td><td class="border border-gray-200 px-4 py-3 text-center text-green-600 font-bold">❌ 방지</td><td class="border border-gray-200 px-4 py-3 text-center text-green-600 font-bold">❌ 방지</td><td class="border border-gray-200 px-4 py-3 text-center font-bold text-purple-700">최저</td></tr>
</tbody></table>
</div>
<div class="insight-box mt-4"><p class="text-sm text-gray-700">격리 수준이 한 단계 올라갈 때마다 이상 현상이 <strong>하나씩 제거</strong>된다 (Dirty → Non-Repeatable → Phantom 순). 이것이 <strong>격리성-동시성 트레이드오프</strong>의 본질이다.</p></div>
</div>

<!-- Dirty Read 타이밍 다이어그램 (HTML/CSS 시각화) -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">⏱️ Dirty Read 발생 타이밍 다이어그램</h3>
<div class="bg-gray-50 rounded-xl p-6 overflow-x-auto">
<div class="min-w-[500px]">
<!-- 시간축 -->
<div class="flex items-center mb-4">
<span class="text-xs font-bold text-gray-500 w-12">시간 →</span>
<div class="flex-1 h-px bg-gray-300"></div>
</div>
<!-- T1 -->
<div class="flex items-center gap-1 mb-2">
<span class="text-xs font-bold text-blue-700 w-12">T1</span>
<div class="flex items-center gap-1 flex-1">
<div class="bg-blue-100 border border-blue-300 rounded px-2 py-1 text-[10px] text-blue-800 font-medium">BEGIN</div>
<span class="text-gray-400 text-xs">→</span>
<div class="bg-blue-500 text-white rounded px-2 py-1 text-[10px] font-bold">UPDATE X=2000</div>
<div class="flex-1 border-t-2 border-dashed border-blue-300 mx-1"></div>
<div class="bg-red-500 text-white rounded px-2 py-1 text-[10px] font-bold">ROLLBACK ✗</div>
</div>
</div>
<!-- 화살표 표시 -->
<div class="flex items-center ml-12 mb-2">
<div class="w-[120px]"></div>
<div class="flex flex-col items-center">
<span class="text-red-500 text-lg">↓</span>
<span class="text-[9px] text-red-600 font-bold bg-red-50 px-1 rounded">커밋 전 변경값 노출!</span>
</div>
</div>
<!-- T2 -->
<div class="flex items-center gap-1 mb-4">
<span class="text-xs font-bold text-green-700 w-12">T2</span>
<div class="flex items-center gap-1 flex-1">
<div class="w-[60px]"></div>
<div class="bg-green-100 border border-green-300 rounded px-2 py-1 text-[10px] text-green-800 font-medium">BEGIN</div>
<span class="text-gray-400 text-xs">→</span>
<div class="bg-red-100 border-2 border-red-400 rounded px-2 py-1 text-[10px] text-red-800 font-bold">READ X=2000 💀</div>
<span class="text-gray-400 text-xs">→</span>
<div class="bg-green-100 border border-green-300 rounded px-2 py-1 text-[10px] text-green-800">업무처리</div>
<span class="text-gray-400 text-xs">→</span>
<div class="bg-green-500 text-white rounded px-2 py-1 text-[10px] font-bold">COMMIT</div>
</div>
</div>
</div>
</div>
<!-- 구체적 수치 시나리오 -->
<div class="bg-red-50 rounded-xl p-4 border border-red-200 mt-4">
<h4 class="text-sm font-bold text-red-800 mb-2">💰 구체적 수치 시나리오</h4>
<ul class="text-sm text-red-700 space-y-1">
<li>T1: 계좌 A 잔액을 <strong>1,000,000원 → 2,000,000원</strong>으로 변경 (입금)</li>
<li>T2: 계좌 A 조회하여 <strong>2,000,000원</strong>을 읽음 (Dirty Read)</li>
<li>T1: 오류로 <strong>ROLLBACK</strong> → 잔액 원래대로 1,000,000원</li>
<li>T2: 2,000,000원 있다고 판단, <strong>1,500,000원 이체</strong> 처리</li>
<li>결과: 잔액 1,000,000원에서 1,500,000원 이체 → <strong>잔액 부족 오류 또는 데이터 불일치</strong></li>
</ul>
</div>
</div>

<!-- 성능 비교 + MVCC vs Lock -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">📈 성능 분석 및 MVCC vs Lock 비교</h3>

<!-- 성능 비교 표 -->
<h4 class="text-sm font-bold text-gray-700 mb-3">격리 수준별 성능 비교 (TPC-C 기준)</h4>
<div class="overflow-x-auto mb-6">
<table class="w-full border-collapse text-sm">
<thead><tr class="bg-gray-100">
<th class="border border-gray-200 px-3 py-2 text-left font-bold">격리 수준</th>
<th class="border border-gray-200 px-3 py-2 text-center font-bold">TPS (상대값)</th>
<th class="border border-gray-200 px-3 py-2 text-center font-bold">평균 응답시간</th>
<th class="border border-gray-200 px-3 py-2 text-center font-bold">데드락 빈도</th>
<th class="border border-gray-200 px-3 py-2 text-center font-bold">잠금 대기 비율</th>
</tr></thead>
<tbody>
<tr><td class="border border-gray-200 px-3 py-2">Read Uncommitted</td><td class="border border-gray-200 px-3 py-2 text-center">100%</td><td class="border border-gray-200 px-3 py-2 text-center">1.0ms</td><td class="border border-gray-200 px-3 py-2 text-center">거의 없음</td><td class="border border-gray-200 px-3 py-2 text-center">&lt; 1%</td></tr>
<tr class="bg-gray-50"><td class="border border-gray-200 px-3 py-2">Read Committed</td><td class="border border-gray-200 px-3 py-2 text-center">85~95%</td><td class="border border-gray-200 px-3 py-2 text-center">1.2ms</td><td class="border border-gray-200 px-3 py-2 text-center">낮음</td><td class="border border-gray-200 px-3 py-2 text-center">5~10%</td></tr>
<tr><td class="border border-gray-200 px-3 py-2">Repeatable Read</td><td class="border border-gray-200 px-3 py-2 text-center">70~85%</td><td class="border border-gray-200 px-3 py-2 text-center">1.5ms</td><td class="border border-gray-200 px-3 py-2 text-center">보통</td><td class="border border-gray-200 px-3 py-2 text-center">10~20%</td></tr>
<tr class="bg-gray-50"><td class="border border-gray-200 px-3 py-2">Serializable</td><td class="border border-gray-200 px-3 py-2 text-center">50~70%</td><td class="border border-gray-200 px-3 py-2 text-center">2.0~3.0ms</td><td class="border border-gray-200 px-3 py-2 text-center">높음</td><td class="border border-gray-200 px-3 py-2 text-center">20~40%</td></tr>
</tbody></table>
</div>

<!-- MVCC vs Lock 비교 -->
<h4 class="text-sm font-bold text-gray-700 mb-3">MVCC vs Lock 기반 동시성 제어 비교</h4>
<div class="overflow-x-auto">
<table class="w-full border-collapse text-sm">
<thead><tr class="bg-gray-100">
<th class="border border-gray-200 px-3 py-2 text-left font-bold">비교 항목</th>
<th class="border border-gray-200 px-3 py-2 text-center font-bold text-blue-700">Lock 기반 (2PL)</th>
<th class="border border-gray-200 px-3 py-2 text-center font-bold text-green-700">MVCC</th>
</tr></thead>
<tbody>
<tr><td class="border border-gray-200 px-3 py-2 font-medium">읽기-쓰기 동시성</td><td class="border border-gray-200 px-3 py-2 text-center text-red-600">차단 발생 (낮음)</td><td class="border border-gray-200 px-3 py-2 text-center text-green-600">비차단 (높음)</td></tr>
<tr class="bg-gray-50"><td class="border border-gray-200 px-3 py-2 font-medium">쓰기-쓰기 동시성</td><td class="border border-gray-200 px-3 py-2 text-center">차단 발생</td><td class="border border-gray-200 px-3 py-2 text-center">차단 발생 (동일)</td></tr>
<tr><td class="border border-gray-200 px-3 py-2 font-medium">저장 공간 오버헤드</td><td class="border border-gray-200 px-3 py-2 text-center text-green-600">없음</td><td class="border border-gray-200 px-3 py-2 text-center text-red-600">버전 관리 공간 필요</td></tr>
<tr class="bg-gray-50"><td class="border border-gray-200 px-3 py-2 font-medium">가비지 컬렉션</td><td class="border border-gray-200 px-3 py-2 text-center text-green-600">불필요</td><td class="border border-gray-200 px-3 py-2 text-center text-red-600">VACUUM 필요</td></tr>
<tr><td class="border border-gray-200 px-3 py-2 font-medium">데드락 위험</td><td class="border border-gray-200 px-3 py-2 text-center text-red-600">높음</td><td class="border border-gray-200 px-3 py-2 text-center text-green-600">낮음</td></tr>
<tr class="bg-gray-50"><td class="border border-gray-200 px-3 py-2 font-medium">적용 DBMS</td><td class="border border-gray-200 px-3 py-2 text-center">SQL Server(기본), DB2</td><td class="border border-gray-200 px-3 py-2 text-center">PostgreSQL, Oracle, MySQL</td></tr>
</tbody></table>
</div>
</div>

<!-- 현대적 발전 전략 카드 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">🚀 최적화 기법 및 현대적 발전</h3>
<p class="text-gray-500 text-sm mb-4">각 카드를 클릭하면 상세 설명이 펼쳐집니다.</p>
<div class="space-y-3">

<div class="strategy-card bg-indigo-50 rounded-xl p-4 border border-indigo-200" onclick="toggleStrategy(this)">
<div class="strategy-summary"><div class="flex items-center justify-between"><h4 class="text-sm font-bold text-indigo-800">🔍 낙관적 동시성 제어 (OCC)</h4><span class="text-indigo-400 text-xs">클릭하여 펼치기 ▼</span></div></div>
<div class="strategy-detail hidden mt-3"><p class="text-sm text-indigo-700 leading-relaxed">읽기 시점에 잠금을 설정하지 않고, <strong>커밋 시점에 충돌 여부를 검사</strong>한다. 읽기 비율이 높고 쓰기 충돌이 적은 환경(예: 웹 애플리케이션의 상품 조회)에 적합하다.</p></div>
</div>

<div class="strategy-card bg-green-50 rounded-xl p-4 border border-green-200" onclick="toggleStrategy(this)">
<div class="strategy-summary"><div class="flex items-center justify-between"><h4 class="text-sm font-bold text-green-800">📸 Snapshot Isolation (SI)</h4><span class="text-green-400 text-xs">클릭하여 펼치기 ▼</span></div></div>
<div class="strategy-detail hidden mt-3"><p class="text-sm text-green-700 leading-relaxed">트랜잭션 시작 시점의 데이터 스냅샷을 기반으로 읽기 수행. 쓰기 시 <strong>First-Committer-Wins</strong> 규칙 적용. ANSI SQL-92에 미정의. Oracle, PostgreSQL, SQL Server가 지원. 추가로 <strong>Write Skew</strong> 이상 현상 발생 가능.</p></div>
</div>

<div class="strategy-card bg-purple-50 rounded-xl p-4 border border-purple-200" onclick="toggleStrategy(this)">
<div class="strategy-summary"><div class="flex items-center justify-between"><h4 class="text-sm font-bold text-purple-800">⚡ Serializable Snapshot Isolation (SSI)</h4><span class="text-purple-400 text-xs">클릭하여 펼치기 ▼</span></div></div>
<div class="strategy-detail hidden mt-3"><p class="text-sm text-purple-700 leading-relaxed">PostgreSQL 9.1(2011)에서 도입. MVCC 기반 Serializable 격리. 읽기-쓰기 차단 없이 높은 동시성을 유지하면서 직렬 가능성 보장. 충돌 감지 시 해당 트랜잭션을 ROLLBACK시키는 <strong>낙관적 방식</strong>.</p></div>
</div>

<div class="strategy-card bg-amber-50 rounded-xl p-4 border border-amber-200" onclick="toggleStrategy(this)">
<div class="strategy-summary"><div class="flex items-center justify-between"><h4 class="text-sm font-bold text-amber-800">🌐 CAP 정리와 분산 환경</h4><span class="text-amber-400 text-xs">클릭하여 펼치기 ▼</span></div></div>
<div class="strategy-detail hidden mt-3"><p class="text-sm text-amber-700 leading-relaxed">Eric Brewer(2000)의 CAP 정리: 분산 시스템에서 일관성(C)·가용성(A)·분할 내성(P) 세 가지 동시 만족 불가. 격리 수준의 트레이드오프는 단일 노드 수준, 분산 환경에서는 CAP에 의해 더 복잡. <strong>Google Spanner</strong>는 TrueTime API로 분산 Serializable 격리 구현. <strong>BASE 모델</strong>(Basically Available, Soft state, Eventually consistent)은 격리성을 완화하여 확장성 극대화.</p></div>
</div>

</div>
</div>
</div>

<div id="textbook" class="hidden">
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<div class="flex items-center gap-2 mb-6">
<h2 class="text-xl font-bold text-gray-900">📖 원문 학습 — 제1부 상세 해설</h2>
</div>
<div class="textbook-content">

<h3>제1장 개요 및 배경</h3>
<h4>1.1 트랜잭션의 정의와 ACID 속성</h4>
<p>트랜잭션(Transaction)이란 데이터베이스의 상태를 변환하는 하나의 <strong>논리적 작업 단위(Logical Unit of Work)</strong>이다. Jim Gray(1981)가 체계화한 트랜잭션 개념은 <strong>ACID 속성</strong>으로 정의된다.</p>

<table>
<thead><tr><th>속성</th><th>정의</th><th>보장 메커니즘</th></tr></thead>
<tbody>
<tr><td><strong>원자성(Atomicity)</strong></td><td>트랜잭션의 모든 연산이 완전히 수행되거나 전혀 수행되지 않아야 한다</td><td>Undo/Redo 로그, Write-Ahead Logging(WAL)</td></tr>
<tr><td><strong>일관성(Consistency)</strong></td><td>트랜잭션 실행 전후로 데이터베이스가 일관된 상태를 유지해야 한다</td><td>무결성 제약조건, 트리거, 도메인 제약</td></tr>
<tr><td><strong>격리성(Isolation)</strong></td><td>동시에 실행되는 트랜잭션들이 서로 간섭하지 않아야 한다</td><td>격리 수준(Isolation Level), 잠금(Lock), MVCC</td></tr>
<tr><td><strong>지속성(Durability)</strong></td><td>완료(Commit)된 트랜잭션의 결과는 영구적으로 반영되어야 한다</td><td>WAL, 체크포인트(Checkpoint), 이중화</td></tr>
</tbody></table>

<p>본 교재에서 다루는 <strong>격리성(Isolation)</strong>은 ACID 속성 중 동시성 제어(Concurrency Control)와 직접적으로 관련되는 속성이다. 격리성의 수준을 어느 정도로 보장하느냐에 따라 <strong>격리 수준(Isolation Level)</strong>이 결정되며, 이는 동시성(Concurrency)과 데이터 정합성(Consistency) 간의 <strong>트레이드오프(Trade-off)</strong>를 조정하는 핵심 파라미터이다.</p>

<h4>1.2 격리 수준이 필요한 이유</h4>
<p>다수의 트랜잭션이 동시에 실행되는 환경에서, 완벽한 격리(Serializable)는 데이터 정합성을 보장하지만 동시 처리량(Throughput)이 급격히 저하된다. 반대로 격리를 완화하면 동시 처리량은 향상되지만 <strong>읽기 이상 현상(Read Anomaly)</strong>이 발생할 수 있다.</p>
<p>TPC-C 벤치마크 기준으로, Serializable 수준 대비 Read Committed 수준은 약 <strong>30~50%의 처리량 향상</strong>이 보고되며, 이는 잠금 대기(Lock Wait) 시간의 감소에 기인한다. 따라서 ANSI SQL-92 표준은 4단계 격리 수준을 정의하여, 애플리케이션의 요구사항에 따라 적절한 수준을 선택할 수 있도록 하고 있다.</p>

<h3>제2장 동작 환경 — 동시성 제어 기법</h3>
<h4>2.1 잠금 기반 동시성 제어(Lock-Based Concurrency Control)</h4>
<p>전통적 DBMS(Oracle, SQL Server, DB2)는 <strong>2단계 잠금 프로토콜(Two-Phase Locking, 2PL)</strong>을 기반으로 격리성을 보장한다.</p>

<table>
<thead><tr><th>잠금 유형</th><th>기호</th><th>설명</th><th>호환성</th></tr></thead>
<tbody>
<tr><td>공유 잠금(Shared Lock)</td><td>S-Lock</td><td>읽기(Read) 시 설정, 다른 트랜잭션의 읽기 허용</td><td>S-Lock과 호환</td></tr>
<tr><td>배타 잠금(Exclusive Lock)</td><td>X-Lock</td><td>쓰기(Write) 시 설정, 다른 모든 잠금 차단</td><td>모든 잠금과 비호환</td></tr>
</tbody></table>

<p><strong>2단계 잠금 프로토콜</strong>:</p>
<ul>
<li><strong>확장 단계(Growing Phase)</strong>: 잠금을 획득만 하고 해제하지 않는 단계</li>
<li><strong>축소 단계(Shrinking Phase)</strong>: 잠금을 해제만 하고 획득하지 않는 단계</li>
<li>확장 → 축소의 순서를 지키면 <strong>직렬 가능성(Serializability)</strong>이 보장된다</li>
</ul>

<h4>2.2 다중 버전 동시성 제어(MVCC)</h4>
<p>PostgreSQL, MySQL(InnoDB), Oracle은 <strong>MVCC(Multi-Version Concurrency Control)</strong>를 사용하여, 데이터의 여러 버전을 동시에 유지함으로써 읽기와 쓰기가 서로 차단하지 않도록 한다.</p>

<table>
<thead><tr><th>항목</th><th>Lock 기반</th><th>MVCC</th></tr></thead>
<tbody>
<tr><td>읽기-쓰기 충돌</td><td>차단(Blocking) 발생</td><td>과거 버전 읽기로 비차단(Non-blocking)</td></tr>
<tr><td>오버헤드</td><td>잠금 관리 비용</td><td>버전 관리 및 가비지 컬렉션 비용</td></tr>
<tr><td>적용 DBMS</td><td>SQL Server(기본), DB2</td><td>PostgreSQL, Oracle, MySQL InnoDB</td></tr>
<tr><td>데드락 위험</td><td>높음</td><td>낮음 (읽기는 잠금 불필요)</td></tr>
</tbody></table>

<h3>제3장 단계별 처리 과정 — 4단계 격리 수준</h3>
<p>ANSI SQL-92 표준은 4단계의 트랜잭션 격리 수준을 정의한다. 각 격리 수준은 허용하는 읽기 이상 현상의 범위에 따라 구분된다.</p>

<h4>3.1 Level 0: Read Uncommitted (커밋되지 않은 읽기)</h4>
<p><strong>동작 과정</strong>:</p>
<ul>
<li>트랜잭션 T1이 데이터 X를 수정한다 (X: 1000 → 2000)</li>
<li>T1이 아직 COMMIT하지 않은 상태에서, 트랜잭션 T2가 X를 읽는다</li>
<li>T2는 수정된 값 2000을 읽는다 (<strong>Dirty Read 발생</strong>)</li>
<li>T1이 ROLLBACK하면, T2가 읽은 2000은 존재하지 않는 값이 된다</li>
</ul>
<p><strong>잠금 동작</strong>: 쓰기 시 X-Lock을 설정하지만, 읽기 시 S-Lock을 설정하지 않는다. 따라서 다른 트랜잭션이 쓰기 중인 데이터를 잠금 없이 읽을 수 있다.</p>
<p><strong>사용 시나리오</strong>: 대량 데이터의 근사적 집계(Approximate Aggregation)에서 약간의 부정확성을 허용할 때 사용한다. 예: 실시간 대시보드의 개략적 통계.</p>

<h4>3.2 Level 1: Read Committed (커밋된 읽기)</h4>
<p><strong>동작 과정</strong>:</p>
<ul>
<li>트랜잭션 T1이 데이터 X를 수정한다 (X: 1000 → 2000)</li>
<li>T2가 X를 읽으려 하면, T1이 COMMIT할 때까지 대기하거나(Lock 기반) 과거 버전을 읽는다(MVCC)</li>
<li>T1이 COMMIT하면, T2는 COMMIT된 값 2000을 읽는다</li>
<li><strong>Dirty Read는 방지</strong>되지만, T2가 같은 X를 두 번 읽을 때 사이에 T1이 COMMIT하면 <strong>다른 값을 읽는다(Non-Repeatable Read 발생)</strong></li>
</ul>
<p><strong>잠금 동작</strong>: 읽기 시 S-Lock을 설정하되, <strong>읽기 완료 즉시 해제</strong>한다 (Short-duration Read Lock). MVCC에서는 문(Statement) 단위의 스냅샷을 사용한다.</p>
<p><strong>사용 시나리오</strong>: Oracle, PostgreSQL, SQL Server의 <strong>기본 격리 수준</strong>이다. 대부분의 OLTP 환경에서 사용된다.</p>

<h4>3.3 Level 2: Repeatable Read (반복 가능한 읽기)</h4>
<p><strong>동작 과정</strong>:</p>
<ul>
<li>트랜잭션 T2가 데이터 X를 읽는다 (X = 1000)</li>
<li>트랜잭션 T1이 X를 수정하려 하면, T2가 완료될 때까지 차단된다</li>
<li>T2가 다시 X를 읽으면 동일한 값 1000을 읽는다 (<strong>Repeatable Read 보장</strong>)</li>
<li>그러나 T1이 새로운 행(Row)을 INSERT하면, T2가 범위 검색 시 이전에 없던 행이 나타난다 (<strong>Phantom Read 발생</strong>)</li>
</ul>
<p><strong>잠금 동작</strong>: 읽기 시 S-Lock을 설정하고, <strong>트랜잭션이 끝날 때까지 유지</strong>한다 (Long-duration Read Lock). MVCC에서는 트랜잭션 시작 시점의 스냅샷을 사용한다.</p>
<p><strong>사용 시나리오</strong>: MySQL InnoDB의 <strong>기본 격리 수준</strong>이다. 금융 거래의 잔액 조회 등 동일 데이터의 일관된 읽기가 필요한 경우에 사용한다.</p>

<h4>3.4 Level 3: Serializable (직렬화 가능)</h4>
<p><strong>동작 과정</strong>:</p>
<ul>
<li>트랜잭션 T2가 범위 검색(WHERE salary > 3000)을 실행한다</li>
<li>해당 범위에 대한 <strong>범위 잠금(Range Lock)</strong> 또는 <strong>인덱스 잠금</strong>이 설정된다</li>
<li>트랜잭션 T1이 해당 범위에 INSERT, UPDATE, DELETE를 시도하면 <strong>차단</strong>된다</li>
<li><strong>모든 읽기 이상 현상이 방지</strong>되지만, 동시 처리량이 가장 낮다</li>
</ul>
<p><strong>잠금 동작</strong>: 읽기 범위 전체에 잠금을 설정한다. MVCC 기반 DBMS(PostgreSQL)에서는 <strong>SSI(Serializable Snapshot Isolation)</strong> 기법을 사용하여, 직렬 가능성을 위반하는 트랜잭션을 감지하고 ROLLBACK시킨다.</p>
<p><strong>사용 시나리오</strong>: 은행 계좌 이체, 항공권 예약 등 절대적 정합성이 요구되는 트랜잭션에 사용한다.</p>

<h3>제4장 핵심 자료구조 — 읽기 이상 현상 매트릭스</h3>
<h4>4.1 3가지 읽기 이상 현상 정의</h4>
<table>
<thead><tr><th>이상 현상</th><th>정의</th><th>발생 조건</th></tr></thead>
<tbody>
<tr><td><strong>Dirty Read</strong></td><td>커밋되지 않은 다른 트랜잭션의 수정 데이터를 읽는 현상</td><td>쓰기 중인 데이터에 잠금 없이 접근</td></tr>
<tr><td><strong>Non-Repeatable Read</strong></td><td>같은 데이터를 두 번 읽었을 때 값이 다른 현상 (UPDATE로 인한)</td><td>읽기 잠금이 조기 해제되어 중간에 다른 트랜잭션이 수정</td></tr>
<tr><td><strong>Phantom Read</strong></td><td>범위 검색 시 이전에 없던 새로운 행이 나타나는 현상 (INSERT로 인한)</td><td>범위 잠금이 없어 새로운 행 삽입 가능</td></tr>
</tbody></table>

<h4>4.2 격리 수준별 이상 현상 허용 매트릭스</h4>
<table>
<thead><tr><th>격리 수준</th><th>Dirty Read</th><th>Non-Repeatable Read</th><th>Phantom Read</th><th>동시성</th></tr></thead>
<tbody>
<tr><td><strong>Read Uncommitted</strong></td><td>⭕ 발생</td><td>⭕ 발생</td><td>⭕ 발생</td><td>최고</td></tr>
<tr><td><strong>Read Committed</strong></td><td>❌ 방지</td><td>⭕ 발생</td><td>⭕ 발생</td><td>높음</td></tr>
<tr><td><strong>Repeatable Read</strong></td><td>❌ 방지</td><td>❌ 방지</td><td>⭕ 발생</td><td>보통</td></tr>
<tr><td><strong>Serializable</strong></td><td>❌ 방지</td><td>❌ 방지</td><td>❌ 방지</td><td>최저</td></tr>
</tbody></table>

<div class="insight-box"><p><strong>핵심</strong>: 격리 수준이 높아질수록 이상 현상은 줄어들지만 동시 처리량(Throughput)은 감소한다. 이것이 <strong>격리성-동시성 트레이드오프</strong>의 본질이다.</p></div>

<h4>4.3 Dirty Read 발생 메커니즘 상세</h4>
<p><strong>구체적 수치 시나리오</strong>:</p>
<ul>
<li>T1: 계좌 A의 잔액을 1,000,000원에서 2,000,000원으로 변경 (입금 처리)</li>
<li>T2: 계좌 A의 잔액을 조회하여 2,000,000원을 읽음 (Dirty Read)</li>
<li>T1: 오류 발생으로 ROLLBACK → 계좌 A의 잔액은 원래대로 1,000,000원</li>
<li>T2: 2,000,000원이 있다고 판단하고 1,500,000원을 이체 처리</li>
<li><strong>결과</strong>: 실제 잔액 1,000,000원에서 1,500,000원이 이체되어 <strong>잔액 부족 오류</strong> 또는 <strong>데이터 불일치</strong> 발생</li>
</ul>

<h3>제5장 성능 분석</h3>
<h4>5.1 격리 수준별 성능 비교</h4>
<p>TPC-C 벤치마크 환경(100 Warehouse, 10 Terminal)에서의 일반적인 성능 비교이다.</p>
<table>
<thead><tr><th>격리 수준</th><th>TPS (상대값)</th><th>평균 응답시간</th><th>데드락 빈도</th><th>잠금 대기 비율</th></tr></thead>
<tbody>
<tr><td>Read Uncommitted</td><td>100% (기준)</td><td>1.0ms</td><td>거의 없음</td><td>&lt; 1%</td></tr>
<tr><td>Read Committed</td><td>85~95%</td><td>1.2ms</td><td>낮음</td><td>5~10%</td></tr>
<tr><td>Repeatable Read</td><td>70~85%</td><td>1.5ms</td><td>보통</td><td>10~20%</td></tr>
<tr><td>Serializable</td><td>50~70%</td><td>2.0~3.0ms</td><td>높음</td><td>20~40%</td></tr>
</tbody></table>
<div class="insight-box"><p><strong>실무적 함의</strong>: 대부분의 OLTP 시스템은 Read Committed를 기본으로 사용하며, 특정 트랜잭션만 필요에 따라 Repeatable Read 또는 Serializable로 격상한다.</p></div>

<h4>5.2 MVCC vs Lock 기반의 성능 차이</h4>
<table>
<thead><tr><th>비교 항목</th><th>Lock 기반 (2PL)</th><th>MVCC</th></tr></thead>
<tbody>
<tr><td>읽기-쓰기 동시성</td><td>차단 발생 (낮음)</td><td>비차단 (높음)</td></tr>
<tr><td>쓰기-쓰기 동시성</td><td>차단 발생</td><td>차단 발생 (동일)</td></tr>
<tr><td>저장 공간 오버헤드</td><td>없음</td><td>버전 관리 공간 필요</td></tr>
<tr><td>가비지 컬렉션 필요</td><td>불필요</td><td>주기적 VACUUM 필요 (PostgreSQL)</td></tr>
<tr><td>장기 트랜잭션 영향</td><td>데드락 위험 증가</td><td>Bloat(버전 누적) 위험</td></tr>
</tbody></table>

<h3>제6장 최적화 기법 및 현대적 발전</h3>
<h4>6.1 낙관적 동시성 제어(Optimistic Concurrency Control)</h4>
<p>읽기 시점에는 잠금을 설정하지 않고, 커밋 시점에 충돌 여부를 검사한다. 읽기 비율이 높고 쓰기 충돌이 적은 환경(예: 웹 애플리케이션의 상품 조회)에 적합하다.</p>

<h4>6.2 Snapshot Isolation (SI)</h4>
<p>트랜잭션 시작 시점의 데이터 스냅샷을 기반으로 읽기를 수행하며, 쓰기 시에는 <strong>First-Committer-Wins</strong> 규칙을 적용한다. ANSI SQL-92에는 정의되지 않았지만, Oracle, PostgreSQL, SQL Server가 실질적으로 지원하며, <strong>Write Skew</strong> 이상 현상이 추가로 발생할 수 있다.</p>

<h4>6.3 Serializable Snapshot Isolation (SSI)</h4>
<p>PostgreSQL 9.1(2011)에서 도입된 SSI는 MVCC 기반으로 Serializable 격리를 구현한다. 기존 2PL 기반 Serializable과 달리, 읽기-쓰기 차단이 없어 높은 동시성을 유지하면서도 직렬 가능성을 보장한다. 충돌이 감지되면 해당 트랜잭션을 ROLLBACK시키는 <strong>낙관적 방식</strong>이다.</p>

<h3>제7장 연관 이론 연결</h3>
<h4>7.1 동시성 제어와 직렬 가능성(Serializability) 이론</h4>
<p>Eswaran(1976)이 증명한 <strong>2PL 정리</strong>는 &ldquo;2단계 잠금 프로토콜을 따르는 모든 스케줄은 직렬 가능하다&rdquo;는 것이다. 격리 수준은 이 2PL 프로토콜의 잠금 범위와 유지 기간을 조절하여 직렬 가능성의 수준을 단계적으로 완화한 것이다.</p>

<h4>7.2 CAP 정리와의 연결</h4>
<p>Eric Brewer(2000)의 <strong>CAP 정리</strong>에 의하면 분산 시스템에서 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance) 세 가지를 동시에 만족할 수 없다. 격리 수준의 트레이드오프는 단일 노드에서의 일관성-가용성 트레이드오프이며, 분산 환경에서는 CAP 정리에 의해 더 복잡한 선택이 요구된다. Google Spanner는 <strong>TrueTime API</strong>를 통해 분산 환경에서도 Serializable 격리를 구현하였다.</p>

<h4>7.3 ACID vs BASE 모델</h4>
<p>전통적 RDBMS의 ACID 트랜잭션과 대비되는 NoSQL의 <strong>BASE(Basically Available, Soft state, Eventually consistent)</strong> 모델은 격리성을 완화하여 가용성과 확장성을 극대화한다. 이는 격리 수준의 트레이드오프를 분산 시스템 수준으로 확장한 개념이다.</p>

<h3>제8장 시험 출제 관점</h3>
<p><strong>기출 연계</strong>: 트랜잭션 격리 수준은 데이터베이스 영역에서 가장 빈출되는 토픽 중 하나이다. &ldquo;ACID 속성 설명&rdquo;, &ldquo;격리 수준 4단계&rdquo;, &ldquo;Dirty Read의 정의와 방지&rdquo;가 1교시에서 출제되며, 2교시에서는 &ldquo;동시성 제어 기법 비교&rdquo;, &ldquo;MVCC 동작 원리&rdquo; 등과 결합하여 출제된다.</p>

<p><strong>답안 구성 전략</strong>:</p>
<ul>
<li>서론(15%): ACID 속성 중 격리성(Isolation) 정의 → 동시성-정합성 트레이드오프 → 격리 수준의 필요성</li>
<li>본론(75%): 4단계 격리 수준 정의 + 이상 현상 매트릭스(필수 도식) + Dirty Read 흐름도 + MVCC 비교</li>
<li>결론(10%): SI/SSI 등 현대적 발전 + 분산 환경에서의 격리(CAP 정리 연결)</li>
</ul>

</div>
</div>
</div>

<div id="script" class="hidden">
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<div class="flex items-center gap-2 mb-2">
<span class="px-3 py-1 bg-amber-100 text-amber-800 rounded-full text-xs font-bold">🔒 멘토 전용</span>
<h2 class="text-xl font-bold text-gray-900">🎬 강의 스크립트</h2>
</div>
<div class="bg-amber-50 border border-amber-200 rounded-lg p-3 mb-6 text-sm text-amber-700">
이 탭은 멘토 전용입니다. URL에 <code class="bg-amber-100 px-1 rounded">?mentor=true</code> 파라미터를 추가하면 접근할 수 있습니다.
</div>
<div class="textbook-content">

<h4>🎬 [도입부 — 약 3분]</h4>
<p>안녕하세요, 여러분. 오늘은 데이터베이스 영역에서 거의 단골로 출제되는 <strong>트랜잭션 격리 수준</strong>을 다뤄보겠습니다.</p>
<p>이 토픽이 왜 중요하냐면요, 데이터베이스 문제에서 &ldquo;ACID 속성&rdquo;이 나오면 격리성이 반드시 나오고, 격리성을 물어보면 격리 수준 4단계가 필수거든요. 거기다 &ldquo;Dirty Read가 뭔지 설명하시오&rdquo;라는 문제가 단독으로 나올 수도 있고, &ldquo;동시성 제어 기법을 비교하시오&rdquo;라는 2교시형 문제에서도 격리 수준이 기초가 되는 토픽이에요. 한 마디로 가성비가 엄청 좋은 토픽이에요.</p>
<p>자, 먼저 기본 개념부터 잡고 가겠습니다. 트랜잭션이 뭐냐면, 데이터베이스의 상태를 변환하는 논리적 작업 단위예요. 쉽게 말하면 &ldquo;은행에서 돈을 이체하는 것&rdquo; 같은 하나의 완결된 작업이에요. A 계좌에서 100만원 빼고, B 계좌에 100만원 넣는 거 — 이 두 개 연산이 하나로 묶여야 하잖아요? 중간에 하나만 되면 안 되니까요. 이 트랜잭션이 가져야 할 성질이 ACID인데요, <span class="highlight">&ldquo;원일격지&rdquo;</span>로 외우세요. 원자성, 일관성, 격리성, 지속성. 서론에서 ACID를 한 줄 정의하고 시작하면 깔끔해요. 오늘 우리가 깊이 파볼 건 이 중에서 <strong>격리성(Isolation)</strong>이에요.</p>
<p>격리성이 왜 문제가 되냐면요, 데이터베이스에는 동시에 수십, 수백 개의 트랜잭션이 실행되거든요. 여러분 은행 앱 생각해보세요. 같은 시간에 수천 명이 동시에 이체하잖아요? 완벽하게 한 명씩 순서대로 처리하면 데이터는 안전하지만 너무 느려요. 이체 하나에 10초씩 걸리면 고객이 난리가 나겠죠. 그래서 어느 정도 동시에 처리하면서도 데이터 정합성을 지키는 방법이 필요한 거예요. 이 <strong>동시성과 정합성 사이의 트레이드오프</strong>를 조절하는 게 바로 <strong>격리 수준(Isolation Level)</strong>이에요. ANSI SQL-92 표준에서 4단계로 정의했어요.</p>

<h4>🎬 [핵심 설명 — 4단계 격리 수준 (약 7분)]</h4>
<p>자, 순서대로 따라가 봅시다. 격리 수준은 4단계가 있어요. <span class="highlight">&ldquo;언커리시&rdquo;</span>로 외우세요. Read Uncommitted, Read Committed, Repeatable Read, Serializable.</p>
<p>중요한 건요, 아래에서 위로 올라갈수록 격리가 강해지고 데이터는 안전해지지만, 그만큼 동시 처리량이 떨어진다는 거예요. 이게 핵심 <strong>트레이드오프</strong>예요. 시험에서 이 트레이드오프를 꼭 명시해야 해요. &ldquo;격리 수준은 동시성과 데이터 정합성 간의 트레이드오프를 조정하는 메커니즘이다&rdquo; — 이 한 문장을 서론에 넣으면 핵심을 바로 짚는 거예요.</p>
<p><strong>Level 0: Read Uncommitted</strong>부터 보겠습니다. 이건 가장 느슨한 수준이에요. 다른 트랜잭션이 아직 커밋하지 않은 데이터도 읽을 수 있어요. 여기서 <strong>Dirty Read</strong>가 발생하는 거예요. 구체적으로 시나리오를 보면요, T1이 계좌 잔액을 100만원에서 200만원으로 바꿨어요. 아직 커밋 안 했는데, T2가 읽으면 200만원이 보여요. 그런데 T1이 &ldquo;아, 실수했다&rdquo; 하고 롤백하면? T2가 읽은 200만원은 존재하지 않는 유령 같은 데이터가 되는 거예요. 이게 Dirty Read이고, 가장 위험한 이상 현상이에요. 답안에 이 시나리오를 꼭 쓰세요. 금액을 구체적으로 넣으면 채점관이 바로 이해하거든요.</p>
<p><strong>Level 1: Read Committed</strong>는 커밋된 데이터만 읽을 수 있어요. Dirty Read는 방지되지만, 같은 데이터를 두 번 읽었을 때 그 사이에 다른 트랜잭션이 커밋하면 값이 달라지는 <strong>Non-Repeatable Read</strong>가 발생해요. 이게 Oracle이랑 PostgreSQL의 기본 격리 수준이에요. 대부분의 OLTP 시스템이 이 수준을 써요.</p>
<p><strong>Level 2: Repeatable Read</strong>는 한 번 읽은 데이터는 트랜잭션이 끝날 때까지 다시 읽어도 같은 값이 보장돼요. 그런데 범위 검색할 때 새로운 행이 끼어드는 <strong>Phantom Read</strong>는 막지 못해요. &ldquo;salary > 3000인 직원을 조회했는데, 두 번째 조회할 때 새로운 직원이 하나 더 나타났다&rdquo; — 이게 팬텀이에요. 이건 MySQL InnoDB의 기본 격리 수준이에요.</p>
<p><strong>Level 3: Serializable</strong>은 가장 강력한 수준이에요. 모든 이상 현상을 방지해요. 사실상 트랜잭션들이 순서대로 실행되는 것처럼 동작하는 거예요. 대신 동시 처리량이 Read Uncommitted 대비 50~70% 수준으로 떨어져요. 은행 계좌 이체나 항공권 예약 같은 절대적 정합성이 필요한 곳에서만 써요.</p>

<h4>🎬 [핵심 설명 — 이상 현상과 매트릭스 (약 5분)]</h4>
<p>자, 이제 가장 중요한 부분입니다. 시험에 나오면 반드시 그려야 하는 <strong>이상 현상 매트릭스</strong>예요.</p>
<p>이상 현상은 세 가지예요. <span class="highlight">&ldquo;더넌팬&rdquo;</span>으로 외우세요. Dirty Read, Non-Repeatable Read, Phantom Read.</p>
<p>핵심이 뭐냐면요, 격리 수준이 한 단계 올라갈 때마다 이상 현상이 <strong>하나씩</strong> 제거된다는 거예요. Read Uncommitted는 세 개 다 발생하고, Read Committed로 올라가면 Dirty Read가 사라지고, Repeatable Read로 올라가면 Non-Repeatable Read도 사라지고, Serializable로 올라가면 Phantom Read까지 사라져요. 이 패턴을 기억하면 매트릭스를 안 외워도 시험장에서 바로 그릴 수 있어요.</p>
<p>답안지에 표를 그릴 때요, 행은 4개 격리 수준, 열은 3개 이상 현상으로 하고, O(발생)/X(방지)로 채우세요. 그리고 맨 오른쪽에 &ldquo;동시성&rdquo; 열을 추가해서 최고/높음/보통/최저를 넣으면 한눈에 트레이드오프가 보여요.</p>
<p>Dirty Read 흐름도도 꼭 그려야 해요. T1과 T2를 시간축 위에 놓고, T1이 UPDATE → T2가 READ → T1이 ROLLBACK — 이 세 시점을 화살표로 표시하면 돼요. 계좌 잔액 100만원을 200만원으로 바꾸는 구체적 숫자를 넣으면 감점 요소가 확실히 줄어들거든요.</p>
<p>동시성 제어 기법 비교도 중요한데요, Lock 기반과 MVCC를 비교하는 표를 하나 넣으면 돼요. 가장 큰 차이가 뭐냐면, Lock 기반은 읽기와 쓰기가 서로 차단(Blocking)되지만, MVCC는 과거 버전을 읽기 때문에 차단이 안 돼요. 그래서 MVCC가 동시 처리량이 더 높아요. PostgreSQL, Oracle이 MVCC를 쓰는 이유가 이거예요. 단, MVCC도 공짜가 아니에요. 버전을 여러 개 유지해야 하니까 저장 공간이 더 필요하고, PostgreSQL에서는 VACUUM이라는 가비지 컬렉션 작업이 필요하거든요. 이런 장단점을 비교표로 정리하면 깔끔해요.</p>

<h4>🎬 [답안 작성 팁 — 약 3분]</h4>
<p>실전 팁 정리할게요.</p>
<p>서론에서는 ACID 속성 중 격리성을 한 줄로 정의하고, &ldquo;동시성과 정합성의 트레이드오프를 조정하기 위해 ANSI SQL-92에서 4단계 격리 수준을 정의하였다&rdquo;로 연결하세요.</p>
<p>본론의 핵심은 <strong>두 가지 도식</strong>이에요. 첫째, 이상 현상 매트릭스. 둘째, Dirty Read 타이밍 다이어그램. 이 두 개를 답안지에 그리면 본론의 60%가 채워져요. 나머지는 각 격리 수준의 잠금 동작을 2~3줄씩 설명하면 됩니다.</p>
<p>차별화 포인트로는요, ANSI SQL-92에 없는 <strong>Snapshot Isolation</strong>을 한 줄 언급하세요. &ldquo;ANSI SQL-92의 4단계 격리 수준 외에, 실무적으로 Snapshot Isolation이 Oracle, PostgreSQL에서 광범위하게 사용되며, Write Skew라는 추가 이상 현상이 발생할 수 있다.&rdquo; 이 한 줄이 채점관 눈에 확 띄거든요.</p>
<p>결론에서는 <strong>CAP 정리</strong>와 연결하세요. &ldquo;단일 노드의 격리 수준 트레이드오프는 분산 환경에서 CAP 정리에 의한 일관성-가용성 트레이드오프로 확장된다. Google Spanner는 TrueTime API를 통해 분산 환경에서 Serializable 격리를 구현한 사례이다.&rdquo; 이렇게 쓰면 이론적 깊이와 최신 기술 이해를 동시에 보여줄 수 있어요.</p>
<p>각 DBMS의 기본 격리 수준도 외워두세요. Oracle/PostgreSQL은 Read Committed, MySQL InnoDB는 Repeatable Read. 이걸 알면 실무 경험이 있다는 인상을 줄 수 있거든요. &ldquo;왜 MySQL만 Repeatable Read가 기본이냐&rdquo;고 궁금하실 수 있는데, MySQL InnoDB가 갭 락(Gap Lock)이라는 기법으로 Phantom Read까지 상당 부분 방지해주기 때문에, Repeatable Read에서도 사실상 Serializable에 가까운 정합성을 제공하거든요. 이런 디테일을 한 줄 쓰면 &ldquo;이 사람은 진짜 아는구나&rdquo; 하는 인상을 줄 수 있어요.</p>

<h4>🎬 [마무리 — 약 2분]</h4>
<p>자, 오늘 핵심을 정리합니다.</p>
<p>4단계 격리 수준 <span class="highlight">&ldquo;언커리시&rdquo;</span>, 3가지 이상 현상 <span class="highlight">&ldquo;더넌팬&rdquo;</span>, ACID 속성 <span class="highlight">&ldquo;원일격지&rdquo;</span>. 이 세 개 두문자어가 뼈대예요.</p>
<p>그리고 핵심 패턴을 기억하세요. 격리 수준이 올라가면 이상 현상이 하나씩 사라지고, 동시성이 떨어진다. 이 트레이드오프가 본질이에요.</p>
<p>숫자도 기억하세요. Serializable은 Read Uncommitted 대비 TPS가 50~70% 수준이에요. Dirty Read 시나리오에서 계좌 잔액 100만원, 200만원 구체적 숫자를 꼭 쓰세요. 숫자가 들어가면 채점관이 &ldquo;아, 이 사람은 실제 동작을 이해하고 있구나&rdquo; 하고 느끼거든요.</p>
<p>그리고 이 토픽은 다른 토픽과 연결 고리가 아주 많아요. ACID 속성, 동시성 제어(2PL, Timestamp Ordering), 잠금(Lock)과 데드락, MVCC — 이 토픽들이 전부 격리 수준을 기반으로 확장되는 거예요. 2교시형으로 &ldquo;동시성 제어 기법을 비교하시오&rdquo;가 나오면 격리 수준이 서론이 되고, &ldquo;NoSQL의 BASE 모델&rdquo;이 나오면 ACID와의 대비가 서론이 돼요. 분산 데이터베이스에서 CAP 정리를 물어보면 또 격리 수준의 트레이드오프가 기초가 되고요. 그러니까 이 토픽 하나를 확실히 잡아두면 데이터베이스 영역의 여러 문제에 응용할 수 있습니다.</p>
<p>다음 강의에서 뵙겠습니다. 화이팅하세요!</p>

</div>
</div>
</div>

<div id="quiz" class="hidden">
<!-- AI 퀴즈 영역 -->
            <!-- AI 실전 퀴즈 영역 -->
            <div class="bg-indigo-50 rounded-xl p-6 border border-indigo-100 mb-8">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="font-bold text-indigo-900 text-lg flex items-center"><span class="mr-2">🧠</span> AI 실전 문제 생성</h3>
                    <button onclick="generateQuiz()" id="btn-quiz-gen" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-sm transition-colors flex items-center gap-2"><span>✨ 새로운 문제 생성</span></button>
                </div>
                <div id="quiz-loading" class="hidden py-8 text-center">
                    <div class="typing-indicator flex justify-center mb-2"><span></span><span></span><span></span></div>
                    <p class="text-indigo-600 text-sm">AI가 문제를 출제하고 있습니다...</p>
                </div>
                <div id="quiz-container" class="hidden space-y-4">
                    <div class="bg-white p-5 rounded-lg shadow-sm border border-indigo-100">
                        <div class="flex items-start gap-2 mb-4">
                            <span id="quiz-type-badge" class="bg-indigo-100 text-indigo-800 text-xs font-bold px-2 py-1 rounded whitespace-nowrap mt-1">객관식</span>
                            <p id="quiz-question" class="font-bold text-gray-800 text-lg"></p>
                        </div>
                        <div id="quiz-options" class="space-y-2"></div>
                        <div id="quiz-input-area" class="hidden mt-4">
                            <div class="flex gap-2">
                                <input type="text" id="quiz-answer-input" placeholder="정답을 입력하세요" class="flex-grow border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                <button onclick="checkShortAnswer()" id="btn-short-submit" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-bold">제출</button>
                            </div>
                        </div>
                    </div>
                    <div id="quiz-feedback" class="hidden bg-white p-5 rounded-lg border-l-4"></div>
                </div>
                <div id="quiz-placeholder" class="text-center py-8 text-gray-500 border-2 border-dashed border-indigo-200 rounded-lg">
                    <p>&#39;새로운 문제 생성&#39; 버튼을 눌러 실력을 점검해보세요.</p>
                </div>
            </div>



<!-- 암기 노트 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h2 class="text-xl font-bold text-gray-900 mb-4">📝 암기 노트</h2>
<div class="space-y-4">
<div class="bg-indigo-50 rounded-xl p-5 border border-indigo-200">
<h3 class="text-sm font-bold text-indigo-800 mb-2">🏷️ 두문자어 암기법</h3>
<ul class="text-sm text-indigo-700 space-y-2">
<li><strong>4단계 격리 수준</strong>: <span class="highlight">"언커리시"</span> (Uncommitted-Committed-Repeatable-Serializable)</li>
<li><strong>3가지 이상 현상</strong>: <span class="highlight">"더넌팬"</span> (Dirty Read-Non-repeatable Read-Phantom Read)</li>
<li><strong>ACID 속성</strong>: <span class="highlight">"원일격지"</span> (원자성-일관성-격리성-지속성)</li>
<li><strong>핵심 패턴</strong>: 격리 수준이 한 단계 올라갈 때마다 이상 현상이 <strong>하나씩 제거</strong>된다</li>
</ul>
</div>
<div class="bg-green-50 rounded-xl p-5 border border-green-200">
<h3 class="text-sm font-bold text-green-800 mb-2">📊 DBMS별 기본 격리 수준</h3>
<ul class="text-sm text-green-700 space-y-1">
<li><strong>Oracle / PostgreSQL</strong>: Read Committed (커밋된 읽기)</li>
<li><strong>MySQL InnoDB</strong>: Repeatable Read (반복 가능한 읽기)</li>
<li><strong>SQL Server</strong>: Read Committed (기본), Snapshot Isolation 지원</li>
</ul>
</div>
<div class="bg-amber-50 rounded-xl p-5 border border-amber-200">
<h3 class="text-sm font-bold text-amber-800 mb-2">✍️ 답안 작성 골격</h3>
<table class="w-full border-collapse text-sm mt-2">
<thead><tr class="bg-amber-100"><th class="border border-amber-300 px-3 py-2 text-left">구분</th><th class="border border-amber-300 px-3 py-2 text-left">핵심 내용</th><th class="border border-amber-300 px-3 py-2 text-center">비중</th></tr></thead>
<tbody>
<tr><td class="border border-amber-200 px-3 py-2 font-medium">서론</td><td class="border border-amber-200 px-3 py-2">ACID 중 격리성 정의 + 동시성-정합성 트레이드오프</td><td class="border border-amber-200 px-3 py-2 text-center">15%</td></tr>
<tr><td class="border border-amber-200 px-3 py-2 font-medium">본론 1</td><td class="border border-amber-200 px-3 py-2">4단계 격리 수준 정의(동작 방식+잠금 수준)</td><td class="border border-amber-200 px-3 py-2 text-center">25%</td></tr>
<tr><td class="border border-amber-200 px-3 py-2 font-medium">본론 2</td><td class="border border-amber-200 px-3 py-2">이상 현상 매트릭스(3행×4열) + Dirty Read 흐름도</td><td class="border border-amber-200 px-3 py-2 text-center">30%</td></tr>
<tr><td class="border border-amber-200 px-3 py-2 font-medium">본론 3</td><td class="border border-amber-200 px-3 py-2">MVCC와 Lock 기반 비교 + 성능 분석</td><td class="border border-amber-200 px-3 py-2 text-center">20%</td></tr>
<tr><td class="border border-amber-200 px-3 py-2 font-medium">결론</td><td class="border border-amber-200 px-3 py-2">SI/SSI 현대적 발전 + CAP 정리 분산 환경 연결</td><td class="border border-amber-200 px-3 py-2 text-center">10%</td></tr>
</tbody></table>
</div>
</div>
</div>

<!-- 제2부 암기 요약 전체 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h2 class="text-xl font-bold text-gray-900 mb-4">📚 제2부 — 서술형 답안 암기 요약</h2>
<div class="textbook-content">

<h3>1. 한 줄 정의</h3>
<table>
<thead><tr><th>토픽</th><th>한 줄 정의</th></tr></thead>
<tbody><tr><td><strong>트랜잭션 격리 수준</strong></td><td>ANSI SQL-92에서 정의한, 동시 실행 트랜잭션 간 간섭 정도를 4단계로 구분하여 동시성과 데이터 정합성 간의 트레이드오프를 조정하는 메커니즘</td></tr></tbody>
</table>

<h3>2. 핵심 키워드 맵</h3>
<p><strong>ACID 키워드</strong>: 원자성 / 일관성 / 격리성 / 지속성</p>
<p><strong>격리 수준 키워드</strong>: Read Uncommitted / Read Committed / Repeatable Read / Serializable</p>
<p><strong>이상 현상 키워드</strong>: Dirty Read / Non-Repeatable Read / Phantom Read</p>
<p><strong>동시성 제어 키워드</strong>: 2PL / S-Lock / X-Lock / MVCC / Snapshot Isolation / SSI</p>

<h3>3. 두문자어 암기법</h3>
<ul>
<li><strong>4단계 격리 수준</strong>: <span class="highlight">"언커리시"</span> (Uncommitted-Committed-Repeatable-Serializable)</li>
<li><strong>3가지 이상 현상</strong>: <span class="highlight">"더넌팬"</span> (Dirty Read-Non-repeatable Read-Phantom Read)</li>
<li><strong>ACID 속성</strong>: <span class="highlight">"원일격지"</span> (원자성-일관성-격리성-지속성)</li>
<li><strong>격리 수준과 이상 현상 대응</strong>: 격리 수준이 한 단계 올라갈 때마다 이상 현상이 <strong>하나씩 제거</strong>된다 (Dirty → Non-Repeatable → Phantom 순서)</li>
</ul>

<h3>4. 골격 답안 구조</h3>
<p><strong>1교시형 — 단일 답안 구조</strong></p>
<table>
<thead><tr><th>구분</th><th>핵심 내용</th><th>분량 비중</th></tr></thead>
<tbody>
<tr><td><strong>서론</strong></td><td>ACID 중 격리성 정의 + 동시성-정합성 트레이드오프</td><td>15%</td></tr>
<tr><td><strong>본론 1</strong></td><td>4단계 격리 수준 정의(동작 방식 + 잠금 수준)</td><td>25%</td></tr>
<tr><td><strong>본론 2</strong></td><td>이상 현상 매트릭스(3행×4열 표) + Dirty Read 흐름도</td><td>30%</td></tr>
<tr><td><strong>본론 3</strong></td><td>MVCC와 Lock 기반 비교 + 성능 분석</td><td>20%</td></tr>
<tr><td><strong>결론</strong></td><td>SI/SSI 현대적 발전 + CAP 정리 분산 환경 연결</td><td>10%</td></tr>
</tbody></table>

<h3>5. 필수 도식</h3>
<p><strong>도식 1: 격리 수준별 이상 현상 매트릭스</strong><br>[4행(격리 수준) × 3열(이상 현상) + 동시성 수준 열]</p>
<p><strong>도식 2: Dirty Read 발생 타이밍 다이어그램</strong><br>[T1과 T2의 시간축 대비 Read/Write/Commit/Rollback 시점 표시]</p>
<p><strong>도식 3: Lock 기반 vs MVCC 비교표</strong><br>[비교 기준: 읽기-쓰기 동시성, 오버헤드, 데드락, 적용 DBMS]</p>

<h3>6. 차별화 포인트</h3>
<ul>
<li><strong>Dirty Read를 타이밍 다이어그램으로 도식화</strong>하면 시각적 이해도가 높아 감점 요소가 줄어든다. 구체적 수치(계좌 잔액 1,000,000원 → 2,000,000원)를 포함하면 더욱 효과적이다.</li>
<li><strong>ANSI SQL-92에 정의되지 않은 Snapshot Isolation</strong>을 언급하면 최신 기술 이해를 어필할 수 있다. Write Skew 현상도 한 줄 추가하면 차별화된다.</li>
<li><strong>CAP 정리와의 연결</strong>로 단일 노드의 격리 수준 트레이드오프가 분산 환경에서 어떻게 확장되는지 제시하면 이론적 깊이를 보여줄 수 있다.</li>
<li><strong>각 DBMS의 기본 격리 수준</strong>을 명시하면 실무 이해를 보여줄 수 있다 (Oracle/PostgreSQL: Read Committed, MySQL InnoDB: Repeatable Read).</li>
</ul>

</div>
</div>
</div>

<!-- AI 튜터 플로팅 버튼 -->
<button onclick="toggleChat()" class="fixed bottom-6 right-6 w-14 h-14 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 transition-all z-50 flex items-center justify-center text-2xl" title="AI 튜터">💬</button>

<!-- 채팅 사이드바 -->
<div id="chat-sidebar" class="fixed top-0 right-0 w-80 sm:w-96 h-full bg-white shadow-2xl z-50 closed flex flex-col">
<div class="flex items-center justify-between p-4 border-b bg-indigo-600 text-white">
<h3 class="font-bold text-sm">🤖 AI 튜터 — 트랜잭션 격리 수준</h3>
<button onclick="toggleChat()" class="text-white hover:text-indigo-200 text-xl">&times;</button>
</div>
<div id="chat-messages" class="flex-1 overflow-y-auto p-4 flex flex-col gap-2" style="background:#fafafa">
<div class="chat-msg ai">안녕하세요! 트랜잭션 격리 수준에 대해 궁금한 점을 물어보세요. 😊</div>
</div>
<div class="p-3 border-t flex gap-2">
<input id="chat-input" type="text" placeholder="질문을 입력하세요..." class="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-indigo-400" onkeypress="if(event.key==='Enter')sendChat()">
<button onclick="sendChat()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-medium hover:bg-indigo-700">전송</button>
</div>
</div>

<!-- API 설정 모달 -->
<div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
<div class="bg-white rounded-2xl shadow-xl max-w-md w-full p-6">
<div class="flex justify-between items-center mb-4">
<h3 class="text-lg font-bold text-gray-900">🔑 Gemini API 설정</h3>
<button onclick="toggleSettings()" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
</div>
<p class="text-sm text-gray-600 mb-4">AI 퀴즈 생성과 튜터 채팅을 사용하려면 Gemini API Key가 필요합니다.</p>
<input id="api-key-input" type="password" placeholder="Gemini API Key를 입력하세요" class="w-full px-4 py-3 border border-gray-300 rounded-lg text-sm mb-3 focus:outline-none focus:ring-2 focus:ring-indigo-400">
<div class="flex gap-2">
<button onclick="saveApiKey()" class="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-medium hover:bg-indigo-700">저장</button>
<button onclick="toggleSettings()" class="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg text-sm font-medium hover:bg-gray-200">취소</button>
</div>
<p class="text-xs text-gray-400 mt-3">* API Key는 브라우저 로컬 스토리지에 저장됩니다.</p>
</div>
</div>
</main>
<footer class="bg-white mt-12 py-8 border-t border-gray-200">
<div class="max-w-6xl mx-auto px-4 text-center">
<div class="flex flex-col md:flex-row justify-center items-center gap-2 md:gap-6 text-sm text-gray-600 mb-3 font-medium">
<div class="flex items-center gap-2">
<span class="w-2 h-2 rounded-full bg-indigo-500"></span>
<span>박교익PE (132회 정보관리기술사, dr.code92@gmail.com)</span>
</div>
</div>
<p class="text-xs text-gray-400">Copyright &copy; KPC 정보관리기술사 ZIP-UP 심화반. All rights reserved.</p>
</div>
</footer>

<script>
// ─── 멘토 모드 ───
var isMentorMode=new URLSearchParams(window.location.search).get('mentor')==='true';
if(isMentorMode){document.getElementById('nav-script').classList.remove('hidden');}
var sections=isMentorMode?['overview','levels','anomaly','textbook','script','quiz']:['overview','levels','anomaly','textbook','quiz'];

// ─── 탭 네비게이션 ───
function navTo(id){
document.querySelectorAll('.nav-item').forEach(function(el){el.classList.remove('active','text-indigo-600');});
document.getElementById('nav-'+id).classList.add('active','text-indigo-600');
sections.forEach(function(s){document.getElementById(s).classList.add('hidden');});
document.getElementById(id).classList.remove('hidden');
window.scrollTo({top:0,behavior:'smooth'});
}

// ─── 격리 수준 tech-block ───
var levelDetails={
'ru':{title:'Level 0: Read Uncommitted (커밋되지 않은 읽기)',colorClass:'border-red-500 bg-red-50',content:'<p class="text-gray-700 leading-relaxed mb-3">가장 낮은 격리 수준으로, 다른 트랜잭션이 <strong>커밋하지 않은 데이터</strong>도 읽을 수 있습니다.</p><p class="text-gray-700 leading-relaxed mb-3"><strong>동작 과정</strong>: T1이 X를 수정(1000→2000) → T1 미커밋 상태에서 T2가 X를 읽음(2000) → T1 ROLLBACK → T2가 읽은 값은 유령 데이터</p><p class="text-gray-700 leading-relaxed mb-3"><strong>잠금 동작</strong>: 쓰기 시 X-Lock 설정, 읽기 시 S-Lock <em>미설정</em>. 따라서 쓰기 중인 데이터에 잠금 없이 접근 가능.</p><div class="bg-red-100 rounded-lg p-3 mt-2"><p class="text-red-800 text-sm font-medium">⚠️ Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생</p><p class="text-red-700 text-sm mt-1">사용: 대량 데이터의 근사적 집계(Approximate Aggregation) — 실시간 대시보드의 개략적 통계</p></div>'},
'rc':{title:'Level 1: Read Committed (커밋된 읽기)',colorClass:'border-blue-500 bg-blue-50',content:'<p class="text-gray-700 leading-relaxed mb-3"><strong>커밋된 데이터만</strong> 읽을 수 있는 격리 수준입니다. Dirty Read를 방지합니다.</p><p class="text-gray-700 leading-relaxed mb-3"><strong>동작 과정</strong>: T1이 X를 수정 → T2가 읽으려 하면 T1 COMMIT까지 대기(Lock) 또는 과거 버전 읽기(MVCC) → T1 COMMIT 후 T2가 읽음</p><p class="text-gray-700 leading-relaxed mb-3"><strong>잠금 동작</strong>: 읽기 시 S-Lock 설정 후 <em>즉시 해제</em>(Short-duration). MVCC에서는 Statement 단위 스냅샷 사용.</p><div class="bg-blue-100 rounded-lg p-3 mt-2"><p class="text-blue-800 text-sm font-medium">✅ Dirty Read 방지 | ⚠️ Non-Repeatable Read, Phantom Read 발생</p><p class="text-blue-700 text-sm mt-1">Oracle, PostgreSQL, SQL Server의 <strong>기본 격리 수준</strong>. 대부분의 OLTP 환경에서 사용.</p></div>'},
'rr':{title:'Level 2: Repeatable Read (반복 가능한 읽기)',colorClass:'border-green-500 bg-green-50',content:'<p class="text-gray-700 leading-relaxed mb-3">한 번 읽은 데이터는 트랜잭션이 끝날 때까지 <strong>동일한 값</strong>이 보장됩니다.</p><p class="text-gray-700 leading-relaxed mb-3"><strong>동작 과정</strong>: T2가 X를 읽음(1000) → T1이 X를 수정하려 하면 T2 완료까지 차단 → T2가 다시 X를 읽으면 동일한 1000 → 단, T1이 새 행 INSERT 시 범위 검색에서 Phantom 발생</p><p class="text-gray-700 leading-relaxed mb-3"><strong>잠금 동작</strong>: 읽기 시 S-Lock을 설정하고 <em>트랜잭션 끝까지 유지</em>(Long-duration). MVCC에서는 트랜잭션 시작 시점 스냅샷 사용.</p><div class="bg-green-100 rounded-lg p-3 mt-2"><p class="text-green-800 text-sm font-medium">✅ Dirty Read, Non-Repeatable Read 방지 | ⚠️ Phantom Read 발생</p><p class="text-green-700 text-sm mt-1">MySQL InnoDB의 <strong>기본 격리 수준</strong>. 금융 거래 잔액 조회 등에 사용.</p></div>'},
'sr':{title:'Level 3: Serializable (직렬화 가능)',colorClass:'border-purple-500 bg-purple-50',content:'<p class="text-gray-700 leading-relaxed mb-3">가장 강력한 격리 수준으로, 모든 이상 현상을 <strong>완전히 방지</strong>합니다.</p><p class="text-gray-700 leading-relaxed mb-3"><strong>동작 과정</strong>: T2가 범위 검색(WHERE salary > 3000) 실행 → 범위 잠금(Range Lock) 또는 인덱스 잠금 설정 → T1이 해당 범위에 INSERT/UPDATE/DELETE 시도 시 차단</p><p class="text-gray-700 leading-relaxed mb-3"><strong>잠금 동작</strong>: 읽기 범위 전체에 잠금 설정. PostgreSQL에서는 SSI(Serializable Snapshot Isolation) 기법으로 직렬 가능성 위반 트랜잭션을 감지·ROLLBACK.</p><div class="bg-purple-100 rounded-lg p-3 mt-2"><p class="text-purple-800 text-sm font-medium">✅ 모든 이상 현상 방지 | 동시 처리량 최저 (RU 대비 50~70%)</p><p class="text-purple-700 text-sm mt-1">은행 계좌 이체, 항공권 예약 등 절대적 정합성 요구 트랜잭션에 사용.</p></div>'}
};
function updateLevelDetail(key){
document.querySelectorAll('.tech-block').forEach(function(el){el.classList.remove('selected','ring-2','ring-indigo-500','bg-indigo-50','border-indigo-500');});
var el=document.getElementById('block-'+key);
if(el){el.classList.add('selected','ring-2','ring-indigo-500','bg-indigo-50','border-indigo-500');}
var d=levelDetails[key];
var html='<div class="'+d.colorClass+' border-l-4 rounded-r-lg p-5 animate-fade-in"><h4 class="text-lg font-bold text-gray-900 mb-3">'+d.title+'</h4>'+d.content+'</div>';
document.getElementById('level-detail-content').innerHTML=html;
}

// ─── strategy-card 토글 ───
function toggleStrategy(el){
var d=el.querySelector('.strategy-detail');
var s=el.querySelector('.strategy-summary');
if(d.classList.contains('hidden')){
document.querySelectorAll('.strategy-detail').forEach(function(x){x.classList.add('hidden');});
document.querySelectorAll('.strategy-summary').forEach(function(x){x.classList.remove('hidden');});
d.classList.remove('hidden');
s.classList.add('hidden');
}else{
d.classList.add('hidden');
s.classList.remove('hidden');
}
}

// ─── API Key 관리 ───
function getApiKey(){
var k=localStorage.getItem('gemini_api_key');
if(!k){var p=new URLSearchParams(window.location.search);k=p.get('key');}
return k;
}
function saveApiKey(){
var k=document.getElementById('api-key-input').value.trim();
if(k){localStorage.setItem('gemini_api_key',k);toggleSettings();alert('API Key가 저장되었습니다!');}
else{alert('API Key를 입력해주세요.');}
}
function toggleSettings(){
var m=document.getElementById('settings-modal');
m.classList.toggle('hidden');
var k=localStorage.getItem('gemini_api_key');
if(k){document.getElementById('api-key-input').value=k;}
}

// ─── AI 튜터 채팅 ───
function toggleChat(){
var sb=document.getElementById('chat-sidebar');
sb.classList.toggle('open');
sb.classList.toggle('closed');
}
async function sendChat(){
var input=document.getElementById('chat-input');
var msg=input.value.trim();if(!msg)return;
input.value='';
var box=document.getElementById('chat-messages');
box.innerHTML+='<div class="chat-msg user">'+msg+'</div>';
box.innerHTML+='<div id="typing" class="chat-msg ai"><div class="typing-indicator"><span></span><span></span><span></span></div></div>';
box.scrollTop=box.scrollHeight;
var key=getApiKey();
if(!key){document.getElementById('typing').remove();box.innerHTML+='<div class="chat-msg ai">⚠️ API Key가 설정되지 않았습니다. 상단의 🔑 API 버튼을 클릭하여 설정해주세요.</div>';box.scrollTop=box.scrollHeight;return;}
try{
var r=await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key='+key,{
method:'POST',headers:{'Content-Type':'application/json'},
body:JSON.stringify({contents:[{role:'user',parts:[{text:'당신은 정보관리기술사 시험 멘토입니다. "트랜잭션 격리 수준(Isolation Level)과 Dirty Read" 관련 질문에 전문적이고 명쾌하게 답변해주세요. 300자 이내로 핵심만 요약.\n\n질문: '+msg}]}]})
});
var d=await r.json();
document.getElementById('typing').remove();
var answer=d.candidates[0].content.parts[0].text;
if(typeof marked!=='undefined'){answer=marked.parse(answer);}
box.innerHTML+='<div class="chat-msg ai">'+answer+'</div>';
}catch(e){document.getElementById('typing').remove();box.innerHTML+='<div class="chat-msg ai">⚠️ 오류가 발생했습니다: '+e.message+'</div>';}
box.scrollTop=box.scrollHeight;
}

// ─── AI 퀴즈 ───
    (function(){var p=new URLSearchParams(window.location.search);var k=p.get('key');if(k){localStorage.setItem('gemini_api_key',k);}})();

    // ── 퀴즈 ──
    // Bridge: connect quiz JS to existing API key management
    var geminiKey = (typeof getApiKey === 'function') ? (getApiKey() || '') : '';

    var quizTypeHistory = [];
    var currentQuizData = null;
    var quizTopics=[
{category:'ACID 속성과 트랜잭션 기본',keywords:'ACID, 원자성, 일관성, 격리성, 지속성, WAL, 트랜잭션 정의, Jim Gray'},
{category:'4단계 격리 수준',keywords:'Read Uncommitted, Read Committed, Repeatable Read, Serializable, ANSI SQL-92, 잠금 동작'},
{category:'읽기 이상 현상',keywords:'Dirty Read, Non-Repeatable Read, Phantom Read, 이상 현상 매트릭스, 발생 메커니즘'},
{category:'동시성 제어 기법',keywords:'2PL, S-Lock, X-Lock, MVCC, 공유 잠금, 배타 잠금, 확장 단계, 축소 단계'},
{category:'성능 분석과 DBMS 비교',keywords:'TPC-C, TPS, 데드락, 잠금 대기, Oracle, PostgreSQL, MySQL InnoDB, 기본 격리 수준'},
{category:'현대적 발전과 연관 이론',keywords:'Snapshot Isolation, SSI, Write Skew, CAP 정리, BASE 모델, Google Spanner, OCC'}
];
    async function generateQuiz() {
        geminiKey = (typeof getApiKey === 'function') ? (getApiKey() || '') : geminiKey;
        if (!geminiKey) { alert('API Key를 먼저 설정해주세요.'); toggleSettings(); return; }
        var btn = document.getElementById('btn-quiz-gen');
        btn.disabled = true; btn.innerHTML = '<span>생성 중...</span>';
        document.getElementById('quiz-placeholder').classList.add('hidden');
        document.getElementById('quiz-container').classList.add('hidden');
        document.getElementById('quiz-loading').classList.remove('hidden');
        var isMC;
        var recent = quizTypeHistory.slice(-2);
        if (recent.length >= 2 && recent[0] === recent[1]) { isMC = !recent[1]; }
        else { isMC = Math.random() > 0.5; }
        quizTypeHistory.push(isMC);
        var selected = quizTopics[Math.floor(Math.random() * quizTopics.length)];
        var quizType = isMC ? '객관식 (4지선다)' : '단답형';
        var format = isMC
            ? '{"question":"문제","options":["A","B","C","D"],"correctIndex":0,"explanation":"해설"}'
            : '{"question":"문제","correctAnswer":"정답","explanation":"해설"}';
        var prompt = "다음 카테고리에 대한 " + quizType + " 퀴즈 1문제를 만드세요.\n"
            + "카테고리: " + selected.category + "\n"
            + "관련 키워드: " + selected.keywords + "\n"
            + "규칙: 반드시 위 카테고리와 키워드에 직접 관련된 문제를 출제하세요.\n"
            + "JSON 형식으로 응답: " + format;
        try {
            var r = await fetch(
                'https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key=' + geminiKey,
                { method:'POST', headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ contents:[{parts:[{text:prompt}]}], generationConfig:{responseMimeType:"application/json"} })
                }
            );
            var d = await r.json();
            var t = d.candidates[0].content.parts[0].text;
            t = t.replace(/```json\s*/gi,"").replace(/```\s*/g,"").trim();
            var depth=0, start=-1, end=-1;
            for (var i=0;i<t.length;i++) {
                if (t[i]==='{') { if(depth===0) start=i; depth++; }
                else if (t[i]==='}') { depth--; if(depth===0 && start!==-1) { end=i; break; } }
            }
            if (start===-1||end===-1) throw new Error("No JSON found");
            t = t.substring(start, end+1);
            t = t.replace(/[\x00-\x1F\x7F]/g, function(c) { return c==='\n'||c==='\r'||c==='\t' ? ' ' : ''; });
            currentQuizData = JSON.parse(t);
            renderQuiz(isMC);
        } catch(e) {
            document.getElementById('quiz-loading').classList.add('hidden');
            document.getElementById('quiz-placeholder').classList.remove('hidden');
            document.getElementById('quiz-placeholder').innerHTML = '<p class="text-red-500">퀴즈 생성 오류: ' + e.message + '</p>';
        }
        btn.disabled = false; btn.innerHTML = '<span>✨ 새로운 문제 생성</span>';
    }
    function renderQuiz(isMC) {
        document.getElementById('quiz-loading').classList.add('hidden');
        document.getElementById('quiz-feedback').classList.add('hidden');
        document.getElementById('quiz-container').classList.remove('hidden');
        document.getElementById('quiz-type-badge').textContent = isMC ? '객관식' : '단답형';
        document.getElementById('quiz-question').textContent = currentQuizData.question;
        var optDiv = document.getElementById('quiz-options');
        var inputDiv = document.getElementById('quiz-input-area');
        if (isMC) {
            optDiv.classList.remove('hidden');
            inputDiv.classList.add('hidden');
            var h = '';
            var letters = ['A','B','C','D'];
            currentQuizData.options.forEach(function(opt, i) {
                h += '<button onclick="checkMultipleChoice(' + i + ', this)" class="w-full text-left p-4 rounded-lg border border-gray-200 hover:bg-indigo-50 hover:border-indigo-300 transition-all mb-2 flex items-center group">'
                    + '<span class="w-8 h-8 rounded-full bg-gray-100 group-hover:bg-indigo-100 flex items-center justify-center text-sm font-bold text-gray-500 group-hover:text-indigo-600 mr-3 flex-shrink-0">' + letters[i] + '</span>'
                    + '<span class="text-sm text-gray-700">' + opt + '</span></button>';
            });
            optDiv.innerHTML = h;
        } else {
            optDiv.classList.add('hidden');
            inputDiv.classList.remove('hidden');
            document.getElementById('quiz-answer-input').value = '';
            document.getElementById('quiz-answer-input').focus();
        }
    }
    function checkMultipleChoice(idx, btnEl) {
        var correct = idx === currentQuizData.correctIndex;
        document.querySelectorAll('#quiz-options button').forEach(function(b, i) {
            b.disabled = true;
            if (i === currentQuizData.correctIndex) { b.classList.add('bg-green-50','border-green-400'); b.querySelector('span:first-child').classList.add('bg-green-100','text-green-700'); }
            else if (i === idx && !correct) { b.classList.add('bg-red-50','border-red-400'); b.querySelector('span:first-child').classList.add('bg-red-100','text-red-700'); }
        });
        showQuizFeedback(correct, currentQuizData.options[currentQuizData.correctIndex], currentQuizData.explanation);
    }
    async function checkShortAnswer() {
        geminiKey = (typeof getApiKey === 'function') ? (getApiKey() || '') : geminiKey;
        var ans = document.getElementById('quiz-answer-input').value.trim();
        if (!ans) { alert('답을 입력해주세요.'); return; }
        var btn = document.getElementById('btn-short-submit');
        btn.disabled = true; btn.textContent = '채점 중...';
        try {
            var gradingPrompt = "당신은 정보관리기술사 시험 채점관입니다. 아래 문제에 대해 사용자의 답안이 정답으로 인정될 수 있는지 판정하세요.\n\n"
                + "문제: " + currentQuizData.question + "\n"
                + "모범 정답: " + currentQuizData.correctAnswer + "\n"
                + "사용자 답안: " + ans + "\n\n"
                + "판정 기준:\n- 핵심 의미가 동일하면 정답\n- 약어/풀네임 모두 인정\n- 영어/한글 혼용 인정\n- 띄어쓰기/조사 차이는 무시\n- 의미가 명확히 다르면 오답\n\n"
                + "Output JSON: {\"correct\":true/false,\"reason\":\"판정 이유\"}";
            var r = await fetch(
                'https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key=' + geminiKey,
                { method:'POST', headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ contents:[{parts:[{text:gradingPrompt}]}], generationConfig:{responseMimeType:"application/json"} })
                }
            );
            var d = await r.json();
            var gt = d.candidates[0].content.parts[0].text;
            gt = gt.replace(/```json\s*/gi,"").replace(/```\s*/g,"").trim();
            var gd=0,gs=-1,ge=-1;
            for(var i=0;i<gt.length;i++){if(gt[i]==='{'){if(gd===0)gs=i;gd++;}else if(gt[i]==='}'){gd--;if(gd===0&&gs!==-1){ge=i;break;}}}
            if(gs===-1||ge===-1) throw new Error("No JSON");
            gt=gt.substring(gs,ge+1);
            gt=gt.replace(/[\x00-\x1F\x7F]/g,function(c){return c==='\n'||c==='\r'||c==='\t'?' ':'';});
            var result = JSON.parse(gt);
            showQuizFeedback(result.correct, currentQuizData.correctAnswer, currentQuizData.explanation + (result.reason ? ' (AI: ' + result.reason + ')' : ''));
        } catch(e) {
            var normalize = function(s){return s.replace(/\s/g,'').toLowerCase();};
            var correct = normalize(currentQuizData.correctAnswer).includes(normalize(ans)) || normalize(ans).includes(normalize(currentQuizData.correctAnswer));
            showQuizFeedback(correct, currentQuizData.correctAnswer, currentQuizData.explanation + ' (로컬 채점)');
        }
        btn.disabled = false; btn.textContent = '제출';
    }
    function showQuizFeedback(correct, answer, explanation) {
        var fb = document.getElementById('quiz-feedback');
        fb.classList.remove('hidden','border-green-500','bg-green-50','border-red-500','bg-red-50');
        if (correct) {
            fb.classList.add('border-green-500','bg-green-50');
            fb.innerHTML = '<p class="font-bold text-green-700 mb-1">✅ 정답입니다!</p><p class="text-sm text-green-600">' + explanation + '</p>';
        } else {
            fb.classList.add('border-red-500','bg-red-50');
            fb.innerHTML = '<p class="font-bold text-red-700 mb-1">❌ 오답입니다.</p><p class="text-sm text-red-700 mb-1">정답: ' + answer + '</p><p class="text-sm text-red-600">' + explanation + '</p>';
        }
    }
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && document.getElementById('quiz-answer-input') === document.activeElement) { checkShortAnswer(); }
    });
</script>
</body>
</html>
