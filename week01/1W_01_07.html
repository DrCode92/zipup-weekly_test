<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CXL(Compute Express Link) 3.0 — KPC ZIP-UP</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
<style>
body{font-family:'Noto Sans KR',sans-serif}
.def-box{background:linear-gradient(135deg,#eef2ff 0%,#e0e7ff 100%);border-left:4px solid #4f46e5;border-radius:8px;padding:1.25rem;margin-bottom:1rem}
.def-box p{color:#312e81;font-weight:500;margin:0;line-height:1.8}
.insight-box{background-color:#fffbeb;border:1px solid #fde68a;border-radius:8px;padding:1rem;margin:1rem 0}
.insight-box::before{content:'💡';margin-right:.5rem}
.textbook-content h3{font-size:1.25rem;font-weight:700;color:#1e3a8a;margin-top:1.5rem;margin-bottom:.75rem;border-left:4px solid #4f46e5;padding-left:.75rem}
.textbook-content h4{font-size:1.1rem;font-weight:600;color:#374151;margin-top:1rem;margin-bottom:.5rem}
.textbook-content p{margin-bottom:1rem;line-height:1.8;color:#4b5563}
.textbook-content ul{list-style-type:disc;padding-left:1.5rem;margin-bottom:1rem;color:#4b5563}
.textbook-content li{margin-bottom:.5rem;line-height:1.7}
.textbook-content table{width:100%;border-collapse:collapse;margin-bottom:1.5rem;font-size:.95rem}
.textbook-content th,.textbook-content td{border:1px solid #e5e7eb;padding:.75rem;text-align:left}
.textbook-content th{background-color:#f9fafb;font-weight:600;color:#1f2937}
.textbook-content .highlight{background-color:#eef2ff;color:#4338ca;font-weight:600;padding:0 4px;border-radius:4px}
.textbook-content pre{background-color:#f8fafc;border:1px solid #e2e8f0;border-radius:8px;padding:1rem;overflow-x:auto;margin-bottom:1rem;font-size:.85rem;line-height:1.6}
.textbook-content code{font-family:'Courier New',monospace}
.tech-block{transition:all .3s ease;cursor:pointer}
.tech-block:hover{transform:translateY(-2px);box-shadow:0 4px 6px -1px rgba(0,0,0,.1)}
.tech-block.selected{ring:2px;ring-color:#4f46e5;background-color:#eef2ff;border-color:#4f46e5}
.nav-item.active{border-bottom:2px solid #4f46e5;color:#4f46e5;font-weight:700}
.chat-msg{border-radius:12px;padding:10px 14px;margin-bottom:10px;max-width:85%;font-size:.95rem}
.chat-msg.user{background-color:#4f46e5;color:#fff;align-self:flex-end;margin-left:auto}
.chat-msg.ai{background-color:#f3f4f6;color:#1f2937;align-self:flex-start;border:1px solid #e5e7eb}
#chat-sidebar{transition:transform .3s ease-in-out}
#chat-sidebar.closed{transform:translateX(100%)}
#chat-sidebar.open{transform:translateX(0)}
.typing-indicator span{display:inline-block;width:6px;height:6px;background-color:#4f46e5;border-radius:50%;animation:typing 1.4s infinite ease-in-out both;margin:0 2px}
.typing-indicator span:nth-child(1){animation-delay:-.32s}
.typing-indicator span:nth-child(2){animation-delay:-.16s}
@keyframes typing{0%,80%,100%{transform:scale(0)}40%{transform:scale(1)}}
.chart-container{position:relative;width:100%;max-width:600px;margin-left:auto;margin-right:auto;height:350px;max-height:400px}
.no-scrollbar::-webkit-scrollbar{display:none}
.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.animate-fade-in{animation:fadeIn .4s ease-out forwards}
.strategy-card{cursor:pointer;transition:all .3s ease}
.strategy-card:hover{transform:translateY(-2px);box-shadow:0 4px 6px -1px rgba(0,0,0,.1)}
</style>
</head>
<body class="bg-stone-100 min-h-screen flex flex-col overflow-x-hidden">
<header class="bg-white shadow-sm sticky top-0 z-40">
<div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8">
<div class="flex justify-between items-center pt-3 pb-1">
<div class="flex flex-col justify-center min-w-0">
<span class="text-[10px] sm:text-xs text-indigo-600 font-bold uppercase tracking-wider leading-tight">KPC 정보관리기술사 ZIP-UP 심화반</span>
<div class="flex items-center gap-2">
<span class="text-lg sm:text-xl font-bold text-gray-900 tracking-tight truncate">CXL(Compute Express Link) 3.0</span>
<span class="text-[10px] sm:text-xs bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded-full font-bold flex-shrink-0">2026</span>
</div>
</div>
</div>
<nav class="flex space-x-1 sm:space-x-4 overflow-x-auto no-scrollbar pb-1 items-center">
<button onclick="navTo('overview')" id="nav-overview" class="nav-item active px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">개요 및 개념</button>
<button onclick="navTo('protocols')" id="nav-protocols" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">3대 프로토콜</button>
<button onclick="navTo('evolution')" id="nav-evolution" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">버전 발전·장치 유형</button>
<button onclick="navTo('textbook')" id="nav-textbook" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">원문 학습</button>
<button onclick="navTo('script')" id="nav-script" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap hidden">🎬 강의 스크립트</button>
<button onclick="navTo('quiz')" id="nav-quiz" class="nav-item px-1 pt-1 pb-2 text-xs sm:text-sm font-medium whitespace-nowrap">퀴즈 &amp; 암기</button>
<span class="w-px h-4 bg-gray-300 flex-shrink-0"></span>
<button onclick="toggleSettings()" class="flex items-center gap-1 px-2.5 py-1 rounded-full text-xs font-medium text-indigo-600 hover:bg-indigo-50 border border-indigo-200 hover:border-indigo-400 transition-all whitespace-nowrap flex-shrink-0" title="API Key 설정">🔑 API</button>
</nav>
</div>
</header>
<main class="flex-grow max-w-5xl w-full mx-auto px-4 sm:px-6 lg:px-8 py-8 space-y-12 pb-24">

<div id="overview">
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 border-l-4 border-indigo-500">
<h2 class="text-xl font-bold text-gray-900 mb-4">📘 CXL(Compute Express Link) 3.0의 정의</h2>
<div class="def-box">
<p><strong>CXL(Compute Express Link)</strong>은 PCIe 물리 계층 위에 3대 프로토콜(CXL.io, CXL.cache, CXL.mem)을 정의하여, CPU-가속기-메모리 간 <strong>캐시 일관성(Cache Coherency)</strong>을 보장하는 개방형 인터커넥트 표준으로, CXL 3.0에서는 <strong>패브릭 구성(Fabric Topology)</strong>과 <strong>다중 레벨 스위칭</strong>을 지원한다.</p>
</div>
<p class="text-gray-600 leading-relaxed mt-4">쉽게 말하면, 서버의 메모리가 부족할 때 PCIe 슬롯에 추가 메모리를 꽂아서 확장할 수 있게 해주는 기술입니다. 기존에는 CPU에 직접 연결된 DIMM 슬롯의 DRAM만 사용할 수 있었지만, CXL을 사용하면 마치 로컬 메모리처럼 <strong>Load/Store 명령으로 직접 접근</strong>할 수 있는 추가 메모리를 장착할 수 있습니다. 특히 CXL 3.0은 여러 서버가 하나의 거대한 메모리 풀을 공유하는 것까지 가능하게 합니다.</p>
</div>

<div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-6">
<div class="bg-white rounded-xl shadow-sm p-5 border-t-4 border-red-400">
<h3 class="text-sm font-bold text-red-700 mb-2">📦 용량 병목 (Capacity Wall)</h3>
<p class="text-gray-600 text-sm leading-relaxed">CPU 소켓당 DIMM 슬롯 수(16~24개)가 고정. DDR5 기준 최대 2~4TB 한계. AI/ML, SAP HANA 등 대규모 인메모리 처리 불가.</p>
</div>
<div class="bg-white rounded-xl shadow-sm p-5 border-t-4 border-amber-400">
<h3 class="text-sm font-bold text-amber-700 mb-2">⚡ 대역폭 병목 (Bandwidth Wall)</h3>
<p class="text-gray-600 text-sm leading-relaxed">CPU-메모리 간 대역폭 한계. DDR5-4800 기준 채널당 38.4GB/s. AI/ML 모델 학습 시 병목 발생.</p>
</div>
<div class="bg-white rounded-xl shadow-sm p-5 border-t-4 border-purple-400">
<h3 class="text-sm font-bold text-purple-700 mb-2">📊 활용률 병목 (Stranding)</h3>
<p class="text-gray-600 text-sm leading-relaxed">서버별 메모리 활용률 불균형. 평균 50~60% 활용. 남는 메모리를 다른 서버가 쓸 수 없어 TCO 증가.</p>
</div>
</div>

<div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
<div class="bg-white rounded-xl shadow-sm p-5 border-t-4 border-indigo-400">
<h3 class="text-sm font-bold text-indigo-700 mb-2">🏢 CXL Consortium</h3>
<p class="text-gray-600 text-sm leading-relaxed">Intel이 2019년 CXL 표준 발표. Intel, AMD, ARM, Samsung, SK hynix, Micron 등 <strong>150개+ 기업</strong> 참여. Gartner: 메모리 비용이 서버 비용의 <strong>40~60%</strong>.</p>
</div>
<div class="bg-white rounded-xl shadow-sm p-5 border-t-4 border-green-400">
<h3 class="text-sm font-bold text-green-700 mb-2">🎯 시험 출제 포인트</h3>
<p class="text-gray-600 text-sm leading-relaxed">CA 영역 최신 기술 토픽. "차세대 인터커넥트", "서버 메모리 확장", "이기종 컴퓨팅 아키텍처" 키워드 출제 가능. 필수 도식: 프로토콜 계층도 + 3대 프로토콜 비교표.</p>
</div>
</div>

<div class="bg-white rounded-xl shadow-sm p-6 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">📊 메모리 병목 유형별 CXL 해결 효과</h3>
<div class="chart-container"><canvas id="bottleneckChart"></canvas></div>
<p class="text-xs text-gray-400 mt-3 text-center">* 상대적 비교를 위한 예시 값입니다.</p>
</div>
<script>
document.addEventListener('DOMContentLoaded',function(){
var ctx=document.getElementById('bottleneckChart');
if(ctx){new Chart(ctx,{type:'radar',data:{labels:['메모리 용량','대역폭','활용률','지연시간','비용 효율','확장성'],datasets:[{label:'기존 DDR5',data:[40,60,50,90,40,30],backgroundColor:'rgba(239,68,68,0.15)',borderColor:'#ef4444',borderWidth:2,pointBackgroundColor:'#ef4444'},{label:'CXL 3.0 적용',data:[85,80,80,70,75,90],backgroundColor:'rgba(79,70,229,0.15)',borderColor:'#4f46e5',borderWidth:2,pointBackgroundColor:'#4f46e5'}]},options:{responsive:true,maintainAspectRatio:false,scales:{r:{min:0,max:100,ticks:{stepSize:20}}},plugins:{legend:{position:'top'}}}});}
});
</script>
</div>

<div id="protocols" class="hidden">
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<h2 class="text-xl font-bold text-gray-900 mb-2">🔗 CXL 3대 프로토콜</h2>
<p class="text-gray-500 text-sm mb-6">각 프로토콜을 클릭하면 상세 동작 방식을 확인할 수 있습니다.</p>
<div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-6">
<div id="block-io" class="tech-block border-2 border-gray-200 rounded-xl p-4 bg-white" onclick="updateProtoDetail('io')">
<div class="flex items-center gap-2 mb-2"><span class="w-8 h-8 rounded-full bg-gray-100 text-gray-600 flex items-center justify-center font-bold text-xs">io</span><span class="text-sm font-bold text-gray-900">CXL.io</span></div>
<p class="text-xs text-gray-500">I/O 프로토콜 (PCIe 호환)</p>
<p class="text-[10px] text-gray-400 mt-1">호스트 → 디바이스</p>
</div>
<div id="block-cache" class="tech-block border-2 border-blue-200 rounded-xl p-4 bg-white" onclick="updateProtoDetail('cache')">
<div class="flex items-center gap-2 mb-2"><span class="w-8 h-8 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center font-bold text-xs">C</span><span class="text-sm font-bold text-gray-900">CXL.cache</span></div>
<p class="text-xs text-blue-600 font-medium">캐시 일관성 프로토콜 ★</p>
<p class="text-[10px] text-gray-400 mt-1">디바이스 → 호스트</p>
</div>
<div id="block-mem" class="tech-block border-2 border-indigo-200 rounded-xl p-4 bg-white" onclick="updateProtoDetail('mem')">
<div class="flex items-center gap-2 mb-2"><span class="w-8 h-8 rounded-full bg-indigo-100 text-indigo-600 flex items-center justify-center font-bold text-xs">M</span><span class="text-sm font-bold text-gray-900">CXL.mem</span></div>
<p class="text-xs text-indigo-600 font-medium">메모리 프로토콜 ★★</p>
<p class="text-[10px] text-gray-400 mt-1">호스트 → 디바이스</p>
</div>
</div>
<div id="proto-detail-content">
<div class="bg-gray-50 rounded-xl p-8 text-center text-gray-400"><p class="text-lg">👆 위의 프로토콜 카드를 클릭하면 상세 정보가 표시됩니다.</p></div>
</div>
</div>

<!-- 프로토콜 계층 구조 시각화 (HTML/CSS) -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">🏗️ CXL 프로토콜 계층 구조</h3>
<div class="max-w-lg mx-auto space-y-2">
<div class="grid grid-cols-3 gap-2">
<div class="bg-gray-100 border-2 border-gray-400 rounded-lg p-3 text-center"><p class="text-xs font-bold text-gray-800">CXL.io</p><p class="text-[10px] text-gray-500">I/O 프로토콜</p></div>
<div class="bg-blue-100 border-2 border-blue-400 rounded-lg p-3 text-center"><p class="text-xs font-bold text-blue-800">CXL.cache</p><p class="text-[10px] text-blue-500">캐시 프로토콜</p></div>
<div class="bg-indigo-100 border-2 border-indigo-400 rounded-lg p-3 text-center"><p class="text-xs font-bold text-indigo-800">CXL.mem</p><p class="text-[10px] text-indigo-500">메모리 프로토콜</p></div>
</div>
<div class="w-full h-px bg-gray-300"></div>
<div class="bg-green-50 border-2 border-green-400 rounded-lg p-3 text-center"><p class="text-xs font-bold text-green-800">CXL 트랜잭션 계층 (Transaction Layer)</p></div>
<div class="w-full h-px bg-gray-300"></div>
<div class="bg-amber-50 border-2 border-amber-400 rounded-lg p-3 text-center"><p class="text-xs font-bold text-amber-800">CXL 링크 계층 (Link Layer)</p></div>
<div class="w-full h-px bg-gray-300"></div>
<div class="bg-purple-50 border-2 border-purple-400 rounded-lg p-3 text-center"><p class="text-xs font-bold text-purple-800">PCIe 물리 계층 (PHY) — PCIe 5.0 / 6.0</p></div>
</div>
<div class="insight-box mt-4"><p class="text-sm text-gray-700"><strong>핵심</strong>: CXL.cache와 CXL.mem이 기존 PCIe에 없는 CXL만의 차별화 프로토콜. Flex Bus를 통해 PCIe/CXL 자동 전환(Negotiation) 지원.</p></div>
</div>

<!-- 3대 프로토콜 비교표 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">📊 3대 프로토콜 비교</h3>
<div class="overflow-x-auto">
<table class="w-full border-collapse text-sm">
<thead><tr class="bg-indigo-50">
<th class="border border-gray-200 px-3 py-2 text-left font-bold text-indigo-800">프로토콜</th>
<th class="border border-gray-200 px-3 py-2 text-left font-bold">역할</th>
<th class="border border-gray-200 px-3 py-2 text-center font-bold">방향</th>
<th class="border border-gray-200 px-3 py-2 text-left font-bold">용도</th>
<th class="border border-gray-200 px-3 py-2 text-left font-bold">PCIe 대비 장점</th>
</tr></thead>
<tbody>
<tr><td class="border border-gray-200 px-3 py-2 font-medium">CXL.io</td><td class="border border-gray-200 px-3 py-2">장치 탐색, 구성, 인터럽트</td><td class="border border-gray-200 px-3 py-2 text-center">H→D</td><td class="border border-gray-200 px-3 py-2">장치 초기화, DMA</td><td class="border border-gray-200 px-3 py-2">PCIe와 동일 (호환성)</td></tr>
<tr class="bg-blue-50"><td class="border border-gray-200 px-3 py-2 font-medium text-blue-700">CXL.cache</td><td class="border border-gray-200 px-3 py-2">디바이스가 호스트 메모리 캐싱</td><td class="border border-gray-200 px-3 py-2 text-center">D→H</td><td class="border border-gray-200 px-3 py-2">GPU/FPGA 호스트 메모리 접근</td><td class="border border-gray-200 px-3 py-2 font-medium text-blue-700">캐시 일관성 보장</td></tr>
<tr class="bg-indigo-50"><td class="border border-gray-200 px-3 py-2 font-medium text-indigo-700">CXL.mem</td><td class="border border-gray-200 px-3 py-2">호스트가 디바이스 메모리 접근</td><td class="border border-gray-200 px-3 py-2 text-center">H→D</td><td class="border border-gray-200 px-3 py-2">CXL 메모리 확장 장치</td><td class="border border-gray-200 px-3 py-2 font-medium text-indigo-700">Load/Store 직접 접근</td></tr>
</tbody></table>
</div>
</div>
</div>

<div id="evolution" class="hidden">
<!-- 버전별 발전 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<h2 class="text-xl font-bold text-gray-900 mb-4">📈 CXL 버전별 발전</h2>
<div class="space-y-4">
<div class="flex items-start gap-4 bg-gray-50 rounded-xl p-4 border border-gray-200">
<span class="w-12 h-12 rounded-full bg-gray-200 text-gray-700 flex items-center justify-center font-bold text-sm flex-shrink-0">1.x</span>
<div><h4 class="text-sm font-bold text-gray-800">CXL 1.0/1.1 (2019/2020)</h4><p class="text-xs text-gray-500">PCIe 5.0 (32GT/s)</p><p class="text-sm text-gray-600 mt-1">3대 프로토콜 정의, 단일 호스트 연결. CXL의 기초 아키텍처 확립.</p></div>
</div>
<div class="flex items-center justify-center"><span class="text-gray-400 text-lg">↓</span></div>
<div class="flex items-start gap-4 bg-blue-50 rounded-xl p-4 border border-blue-200">
<span class="w-12 h-12 rounded-full bg-blue-200 text-blue-700 flex items-center justify-center font-bold text-sm flex-shrink-0">2.0</span>
<div><h4 class="text-sm font-bold text-blue-800">CXL 2.0 (2022)</h4><p class="text-xs text-blue-500">PCIe 5.0 (32GT/s)</p><p class="text-sm text-blue-700 mt-1"><strong>메모리 풀링(Pooling)</strong> 도입, 단일 레벨 스위칭. 여러 호스트가 하나의 메모리 풀을 공유 가능.</p></div>
</div>
<div class="flex items-center justify-center"><span class="text-gray-400 text-lg">↓</span></div>
<div class="flex items-start gap-4 bg-indigo-50 rounded-xl p-4 border border-indigo-300">
<span class="w-12 h-12 rounded-full bg-indigo-500 text-white flex items-center justify-center font-bold text-sm flex-shrink-0">3.0</span>
<div><h4 class="text-sm font-bold text-indigo-800">CXL 3.0 (2022) ★</h4><p class="text-xs text-indigo-500">PCIe 6.0 (64GT/s) — 대역폭 2배</p><p class="text-sm text-indigo-700 mt-1"><strong>패브릭 구성</strong>, 다중 레벨 스위칭, <strong>Back-Invalidate</strong>, 글로벌 패브릭(최대 4096포트). 데이터센터 규모의 공유 메모리 풀.</p></div>
</div>
</div>
</div>

<!-- 장치 유형 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">🔧 CXL 장치 유형 (Type 1/2/3)</h3>
<div class="overflow-x-auto">
<table class="w-full border-collapse text-sm">
<thead><tr class="bg-indigo-50">
<th class="border border-gray-200 px-3 py-2 font-bold text-indigo-800">유형</th>
<th class="border border-gray-200 px-3 py-2 font-bold">사용 프로토콜</th>
<th class="border border-gray-200 px-3 py-2 font-bold">대표 장치</th>
<th class="border border-gray-200 px-3 py-2 font-bold">설명</th>
</tr></thead>
<tbody>
<tr><td class="border border-gray-200 px-3 py-2 font-medium">Type 1</td><td class="border border-gray-200 px-3 py-2">CXL.io + CXL.cache</td><td class="border border-gray-200 px-3 py-2">SmartNIC, 네트워크 가속기</td><td class="border border-gray-200 px-3 py-2">호스트 메모리를 캐싱하는 가속기</td></tr>
<tr class="bg-gray-50"><td class="border border-gray-200 px-3 py-2 font-medium">Type 2</td><td class="border border-gray-200 px-3 py-2">CXL.io + CXL.cache + CXL.mem</td><td class="border border-gray-200 px-3 py-2">GPU, FPGA</td><td class="border border-gray-200 px-3 py-2">자체 메모리 + 호스트 메모리 캐싱</td></tr>
<tr class="bg-indigo-50"><td class="border border-gray-200 px-3 py-2 font-bold text-indigo-700">Type 3 ★</td><td class="border border-gray-200 px-3 py-2 font-medium">CXL.io + CXL.mem</td><td class="border border-gray-200 px-3 py-2 font-medium text-indigo-700">CXL 메모리 확장 장치</td><td class="border border-gray-200 px-3 py-2">메모리 확장 전용 (킬러 앱)</td></tr>
</tbody></table>
</div>
<div class="insight-box mt-3"><p class="text-sm text-gray-700"><strong>Type 3</strong>이 CXL의 가장 혁신적 응용. PCIe 슬롯에 메모리를 장착하여 CPU 소켓당 메모리 용량을 수 TB 이상으로 확장 가능. SK hynix가 96GB CXL DRAM 모듈 양산 중.</p></div>
</div>

<!-- CXL 3.0 핵심 기능 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">🚀 CXL 3.0 핵심 신규 기능</h3>
<p class="text-gray-500 text-sm mb-4">각 카드를 클릭하면 상세 설명이 펼쳐집니다.</p>
<div class="space-y-3">
<div class="strategy-card bg-indigo-50 rounded-xl p-4 border border-indigo-200" onclick="toggleStrategy(this)">
<div class="strategy-summary"><div class="flex items-center justify-between"><h4 class="text-sm font-bold text-indigo-800">🌐 패브릭 구성 (Fabric Topology)</h4><span class="text-indigo-400 text-xs">▼</span></div></div>
<div class="strategy-detail hidden mt-3"><p class="text-sm text-indigo-700 leading-relaxed">다중 레벨 CXL 스위치를 통해 여러 호스트와 CXL 장치를 <strong>메시(Mesh) 형태</strong>로 연결. 데이터센터 규모의 <strong>공유 메모리 풀(Shared Memory Pool)</strong> 구성. 메모리 활용률 50~60% → 80%로 향상.</p></div>
</div>
<div class="strategy-card bg-green-50 rounded-xl p-4 border border-green-200" onclick="toggleStrategy(this)">
<div class="strategy-summary"><div class="flex items-center justify-between"><h4 class="text-sm font-bold text-green-800">⚡ 대역폭 2배 (PCIe 6.0)</h4><span class="text-green-400 text-xs">▼</span></div></div>
<div class="strategy-detail hidden mt-3"><p class="text-sm text-green-700 leading-relaxed">PCIe 6.0의 <strong>64GT/s</strong>를 활용하여 CXL 2.0 대비 대역폭 2배 증가. x16 링크 기준 약 <strong>256GB/s</strong>. PAM4 신호 전송 기술 적용.</p></div>
</div>
<div class="strategy-card bg-amber-50 rounded-xl p-4 border border-amber-200" onclick="toggleStrategy(this)">
<div class="strategy-summary"><div class="flex items-center justify-between"><h4 class="text-sm font-bold text-amber-800">🔄 Back-Invalidate</h4><span class="text-amber-400 text-xs">▼</span></div></div>
<div class="strategy-detail hidden mt-3"><p class="text-sm text-amber-700 leading-relaxed">호스트가 CXL 메모리에 캐싱한 데이터의 일관성을 <strong>CXL 장치 측에서 능동적으로 관리</strong>. 기존에는 호스트 주도로만 일관성 관리가 가능했으나, 3.0에서 양방향 일관성 관리 지원.</p></div>
</div>
<div class="strategy-card bg-purple-50 rounded-xl p-4 border border-purple-200" onclick="toggleStrategy(this)">
<div class="strategy-summary"><div class="flex items-center justify-between"><h4 class="text-sm font-bold text-purple-800">🔢 글로벌 패브릭 (GFD) — 최대 4096포트</h4><span class="text-purple-400 text-xs">▼</span></div></div>
<div class="strategy-detail hidden mt-3"><p class="text-sm text-purple-700 leading-relaxed">최대 <strong>4,096개 포트</strong>를 지원하여 대규모 <strong>컴포저블 인프라(Composable Infrastructure)</strong> 구성. CPU/GPU/메모리를 독립적으로 구성하고 워크로드에 따라 동적 할당하는 SDDC의 핵심.</p></div>
</div>
</div>
</div>

<!-- 적용 사례 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8 mt-6">
<h3 class="text-lg font-bold text-gray-900 mb-4">🏭 적용 사례</h3>
<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
<div class="bg-blue-50 rounded-xl p-5 border border-blue-200">
<h4 class="text-sm font-bold text-blue-800 mb-2">Meta(Facebook) — CXL 메모리 확장 (2023)</h4>
<p class="text-sm text-blue-700 leading-relaxed">Samsung CXL Type 3 시범 도입. AI 추론 서버 메모리 <strong>2배 확장</strong>. 대규모 추천 모델(DLRM) 메모리 부족 해결. 서버 대수 <strong>20% 절감</strong>.</p>
</div>
<div class="bg-green-50 rounded-xl p-5 border border-green-200">
<h4 class="text-sm font-bold text-green-800 mb-2">SK hynix — CXL DRAM 모듈 (2023)</h4>
<p class="text-sm text-green-700 leading-relaxed"><strong>96GB CXL DRAM</strong> 모듈 양산. DDR5 DIMM과 함께 사용하여 서버 메모리 확장. PCIe 5.0 x8 인터페이스, 약 <strong>36GB/s</strong> 대역폭.</p>
</div>
</div>
</div>
</div>

<div id="textbook" class="hidden">
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<h2 class="text-xl font-bold text-gray-900 mb-6">📖 원문 학습 — 제1부 상세 해설</h2>
<div class="textbook-content">

<h3>제1장 개요 및 배경</h3>
<h4>1.1 서버 아키텍처의 메모리 병목 문제</h4>
<p>현대 데이터센터의 워크로드는 AI/ML 학습, 인메모리 데이터베이스(SAP HANA, Redis), 대규모 분석(Apache Spark) 등으로 인해 <strong>메모리 대역폭과 용량에 대한 수요가 폭발적으로 증가</strong>하고 있다. Gartner(2024)에 따르면, 데이터센터 서버의 메모리 비용이 전체 서버 비용의 <strong>40~60%</strong>를 차지하며, 이는 연간 증가 추세이다.</p>
<p>기존 서버 아키텍처에서는 <strong>CPU 소켓에 직접 연결된 DRAM(DDR5)</strong>만 사용할 수 있어, 메모리 확장에 물리적 한계가 있었다. CPU당 메모리 채널 수(8~12채널)와 DIMM 슬롯 수(16~24개)가 고정되어 있기 때문이다.</p>
<table>
<thead><tr><th>병목 유형</th><th>설명</th><th>영향</th></tr></thead>
<tbody>
<tr><td><strong>용량 병목(Capacity Wall)</strong></td><td>CPU 소켓당 최대 메모리 용량 제한 (DDR5 기준 최대 2~4TB)</td><td>대규모 인메모리 처리 불가</td></tr>
<tr><td><strong>대역폭 병목(Bandwidth Wall)</strong></td><td>CPU-메모리 간 대역폭 한계 (DDR5-4800 기준 채널당 38.4GB/s)</td><td>AI/ML 모델 학습 병목</td></tr>
<tr><td><strong>활용률 병목(Stranding)</strong></td><td>서버별 메모리 활용률 불균형 (평균 50~60% 활용)</td><td>메모리 자원 낭비, TCO 증가</td></tr>
</tbody></table>

<h4>1.2 CXL의 등장 배경</h4>
<p>이러한 메모리 병목을 해결하기 위해 Intel이 2019년에 <strong>CXL(Compute Express Link)</strong> 표준을 발표하였다. CXL은 <strong>PCIe 물리 계층 위에서 동작하는 개방형 인터커넥트 표준</strong>으로, CPU와 가속기(GPU, FPGA), 메모리 장치 간의 고속·저지연 연결을 제공한다.</p>
<p>CXL Consortium에는 Intel, AMD, ARM, Samsung, SK hynix, Micron 등 150개 이상의 기업이 참여하고 있으며, 2022년 CXL 3.0이 발표되어 <strong>메모리 풀링(Memory Pooling)</strong>, <strong>패브릭 구성(Fabric Topology)</strong>, <strong>다중 레벨 스위칭</strong> 등 혁신적 기능이 추가되었다.</p>

<h3>제2장 CXL 전체 구조 개관</h3>
<h4>2.1 CXL 프로토콜 계층 구조</h4>
<p>CXL은 PCIe 물리 계층(PHY) 위에 3가지 프로토콜을 정의한다. 이 3가지 프로토콜이 CXL의 핵심 구조이다.</p>

<h4>2.2 3대 프로토콜 비교</h4>
<table>
<thead><tr><th>프로토콜</th><th>역할</th><th>방향</th><th>용도</th><th>PCIe 대비 장점</th></tr></thead>
<tbody>
<tr><td><strong>CXL.io</strong></td><td>I/O 장치 탐색, 구성, 인터럽트 처리</td><td>호스트→디바이스</td><td>장치 초기화, 관리, DMA</td><td>PCIe와 동일 (호환성 유지)</td></tr>
<tr><td><strong>CXL.cache</strong></td><td>디바이스가 호스트 메모리를 캐싱</td><td>디바이스→호스트</td><td>GPU/FPGA의 호스트 메모리 접근</td><td><strong>캐시 일관성(Coherency)</strong> 보장</td></tr>
<tr><td><strong>CXL.mem</strong></td><td>호스트가 디바이스 메모리를 접근</td><td>호스트→디바이스</td><td>CXL 메모리 확장 장치 접근</td><td><strong>로드/스토어(Load/Store)</strong> 방식</td></tr>
</tbody></table>
<div class="insight-box"><p><strong>핵심</strong>: CXL.cache와 CXL.mem이 기존 PCIe에 없는 CXL만의 차별화 프로토콜이다. 특히 CXL.mem은 호스트 CPU가 디바이스에 부착된 메모리를 마치 로컬 메모리처럼 직접 접근(Load/Store)할 수 있게 하는 핵심 프로토콜이다.</p></div>

<h3>제3장 각 계층/구성요소 상세</h3>
<h4>3.1 CXL.io 프로토콜 상세</h4>
<p>CXL.io는 기존 <strong>PCIe 프로토콜과 동일한 기능</strong>을 수행한다. 장치 열거(Enumeration), 구성 공간(Configuration Space) 접근, 인터럽트(MSI/MSI-X), DMA 등을 처리한다.</p>
<p><strong>설계 원칙</strong>: PCIe와의 <strong>하위 호환성(Backward Compatibility)</strong>을 유지하여, 기존 PCIe 소프트웨어 스택(OS 드라이버, BIOS)을 최소한으로 수정하며 CXL을 도입할 수 있도록 하였다.</p>

<h4>3.2 CXL.cache 프로토콜 상세</h4>
<p>CXL.cache는 <strong>디바이스(가속기)가 호스트 CPU의 메모리를 캐싱</strong>할 때 사용하는 프로토콜이다.</p>
<table>
<thead><tr><th>동작</th><th>설명</th></tr></thead>
<tbody>
<tr><td>스누프(Snoop)</td><td>호스트가 디바이스 캐시의 유효성을 확인하는 메시지</td></tr>
<tr><td>데이터 전달(Data Transfer)</td><td>캐시 라인 단위(64B)로 데이터를 전달</td></tr>
<tr><td>소유권 변경(Ownership Change)</td><td>캐시 라인의 Modified/Shared/Invalid 상태 관리 (MESI 프로토콜 확장)</td></tr>
</tbody></table>
<p><strong>실무적 의의</strong>: 기존 PCIe 환경에서 GPU가 호스트 메모리에 접근하려면 DMA를 통한 <strong>데이터 복사(Memcpy)</strong>가 필요하여 지연시간이 μs 단위였으나, CXL.cache를 통하면 <strong>ns 단위</strong>로 접근 가능하다.</p>

<h4>3.3 CXL.mem 프로토콜 상세</h4>
<p>CXL.mem은 <strong>호스트 CPU가 CXL 장치에 부착된 메모리를 직접 접근</strong>하기 위한 프로토콜이다.</p>
<table>
<thead><tr><th>접근 방식</th><th>기존 PCIe (MMIO)</th><th>CXL.mem</th></tr></thead>
<tbody>
<tr><td>접근 지연시간</td><td>μs 단위</td><td>수십~수백 ns 수준</td></tr>
<tr><td>캐싱 가능 여부</td><td>일반적으로 비캐시(Uncacheable)</td><td><strong>캐시 가능(Cacheable)</strong></td></tr>
<tr><td>CPU 명령어</td><td>특수 I/O 명령어 필요</td><td><strong>일반 Load/Store 명령어</strong></td></tr>
<tr><td>소프트웨어 수정</td><td>별도 드라이버 필요</td><td>OS 메모리 관리자 통합 가능</td></tr>
</tbody></table>

<h3>제4장 CXL 버전별 발전과 장치 유형</h3>
<h4>4.1 버전별 발전 이력</h4>
<table>
<thead><tr><th>버전</th><th>발표년도</th><th>물리 계층</th><th>핵심 기능</th></tr></thead>
<tbody>
<tr><td>CXL 1.0/1.1</td><td>2019/2020</td><td>PCIe 5.0 (32GT/s)</td><td>3대 프로토콜 정의, 단일 호스트 연결</td></tr>
<tr><td>CXL 2.0</td><td>2022</td><td>PCIe 5.0 (32GT/s)</td><td><strong>메모리 풀링(Pooling)</strong>, 단일 레벨 스위칭</td></tr>
<tr><td>CXL 3.0</td><td>2022</td><td><strong>PCIe 6.0 (64GT/s)</strong></td><td><strong>패브릭 구성</strong>, 다중 레벨 스위칭, Back-Invalidate, 대역폭 2배</td></tr>
</tbody></table>

<h4>4.2 CXL 장치 유형 (Type 1/2/3)</h4>
<table>
<thead><tr><th>유형</th><th>사용 프로토콜</th><th>대표 장치</th><th>설명</th></tr></thead>
<tbody>
<tr><td><strong>Type 1</strong></td><td>CXL.io + CXL.cache</td><td>SmartNIC, 네트워크 가속기</td><td>호스트 메모리를 캐싱하는 가속기</td></tr>
<tr><td><strong>Type 2</strong></td><td>CXL.io + CXL.cache + CXL.mem</td><td>GPU, FPGA</td><td>자체 메모리를 가지며 호스트 메모리도 캐싱</td></tr>
<tr><td><strong>Type 3</strong></td><td>CXL.io + CXL.mem</td><td><strong>CXL 메모리 확장 장치</strong></td><td>메모리 확장 전용 (DRAM/CXL-PMEM)</td></tr>
</tbody></table>
<div class="insight-box"><p><strong>Type 3 장치</strong>가 CXL의 가장 혁신적인 응용이다. 기존 DIMM 슬롯이 아닌 PCIe 슬롯에 메모리를 장착하여, CPU 소켓당 메모리 용량을 수 TB 이상으로 확장할 수 있다.</p></div>

<h4>4.3 CXL 3.0의 핵심 신규 기능</h4>
<p><strong>[1] 패브릭 구성(Fabric Topology)</strong>: 다중 레벨 CXL 스위치를 통해 여러 호스트와 여러 CXL 장치를 <strong>메시(Mesh) 형태</strong>로 연결. 데이터센터 규모의 <strong>공유 메모리 풀(Shared Memory Pool)</strong>을 구성할 수 있다.</p>
<p><strong>[2] 대역폭 2배</strong>: PCIe 6.0의 64GT/s를 활용하여, CXL 2.0 대비 대역폭이 2배로 증가 (x16 링크 기준 약 256GB/s).</p>
<p><strong>[3] Back-Invalidate</strong>: 호스트가 CXL 메모리에 캐싱한 데이터의 일관성을 CXL 장치 측에서 능동적으로 관리할 수 있는 기능.</p>
<p><strong>[4] 글로벌 패브릭 연결(GFD)</strong>: 최대 4096개의 포트를 지원하여 대규모 컴포저블 인프라를 구성할 수 있다.</p>

<h3>제5장 계층 간 인터페이스와 매핑</h3>
<h4>5.1 프로토콜 간 협업 구조</h4>
<p>3대 프로토콜은 <strong>Flex Bus</strong>라는 물리 계층 인터페이스를 통해 하나의 링크에서 동시에 동작한다.</p>
<table>
<thead><tr><th>장치 유형</th><th>활성 프로토콜</th><th>Flex Bus 동작</th></tr></thead>
<tbody>
<tr><td>기존 PCIe 장치</td><td>PCIe만 사용</td><td>PCIe 모드로 폴백</td></tr>
<tr><td>CXL Type 1</td><td>CXL.io + CXL.cache</td><td>CXL 모드, .mem 비활성</td></tr>
<tr><td>CXL Type 2</td><td>CXL.io + CXL.cache + CXL.mem</td><td>CXL 모드, 3개 프로토콜 모두 활성</td></tr>
<tr><td>CXL Type 3</td><td>CXL.io + CXL.mem</td><td>CXL 모드, .cache 비활성</td></tr>
</tbody></table>

<h4>5.2 메모리 주소 매핑</h4>
<p>CXL.mem을 통해 접근하는 CXL 메모리는 호스트의 <strong>HDM(Host-managed Device Memory)</strong> 영역에 매핑된다. OS는 이 영역을 NUMA 노드로 인식하여 기존 메모리 관리 체계에 통합한다.</p>
<ul>
<li><strong>CXL 메모리 지연시간</strong>: 로컬 DDR5 대비 약 1.5~2배 (150~300ns vs 80~100ns)</li>
<li><strong>NUMA 거리(Distance)</strong>: 원격 소켓 DRAM과 유사하거나 약간 높은 수준</li>
</ul>

<h3>제6장 장단점 및 한계, 현대적 발전</h3>
<h4>6.1 CXL의 장점</h4>
<table>
<thead><tr><th>장점</th><th>설명</th><th>효과</th></tr></thead>
<tbody>
<tr><td>메모리 확장</td><td>PCIe 슬롯을 통한 추가 메모리 장착</td><td>CPU 소켓당 메모리 한계 극복</td></tr>
<tr><td>메모리 풀링</td><td>여러 서버가 공유 메모리 풀을 사용</td><td>메모리 활용률 50%→80% 향상</td></tr>
<tr><td>캐시 일관성</td><td>하드웨어 수준의 캐시 코히어런시</td><td>GPU-CPU 간 데이터 복사 제거</td></tr>
<tr><td>하위 호환성</td><td>PCIe 물리 계층 재사용</td><td>기존 인프라 투자 보호</td></tr>
</tbody></table>

<h4>6.2 CXL의 한계</h4>
<table>
<thead><tr><th>한계</th><th>설명</th></tr></thead>
<tbody>
<tr><td>지연시간 증가</td><td>CXL 메모리는 로컬 DDR 대비 1.5~2배 지연</td></tr>
<tr><td>SW 생태계 미성숙</td><td>OS, 애플리케이션의 CXL 최적화 부족 (NUMA 인식 필요)</td></tr>
<tr><td>보안 과제</td><td>공유 메모리 풀에서의 데이터 격리 및 접근 제어 문제</td></tr>
<tr><td>비용</td><td>CXL 스위치, 컨트롤러 추가 비용</td></tr>
</tbody></table>

<h4>6.3 적용 사례</h4>
<p><strong>사례 1: Meta(Facebook)의 CXL 메모리 확장 (2023)</strong></p>
<p>Meta는 Samsung CXL 메모리 확장기(Type 3)를 시범 도입하여, AI 추론 서버의 메모리 용량을 기존 대비 2배로 확장. 대규모 추천 모델(DLRM)의 메모리 부족 문제를 해결하고, 서버 대수를 <strong>20% 절감</strong>.</p>
<p><strong>사례 2: SK hynix의 CXL DRAM 모듈 (2023)</strong></p>
<p>SK hynix는 96GB CXL DRAM 모듈을 양산하여, 기존 DDR5 DIMM과 함께 사용하여 서버 메모리를 확장. PCIe 5.0 x8 인터페이스로 약 36GB/s 대역폭 제공.</p>

<h3>제7장 연관 이론 연결</h3>
<h4>7.1 NUMA 아키텍처와의 연결</h4>
<p>CXL 메모리는 OS에서 <strong>NUMA 노드</strong>로 관리된다. Linux 커널의 <strong>Tiered Memory</strong> 기능은 CXL 메모리를 하위 티어로 분류하여, 자주 접근하는 데이터는 DDR에, 비활성 데이터는 CXL 메모리에 배치하는 <strong>자동 메모리 계층화</strong>를 수행한다.</p>

<h4>7.2 메모리 계층 구조와의 연결</h4>
<p>컴퓨터 아키텍처의 메모리 계층 구조(레지스터 → L1/L2/L3 캐시 → DRAM → SSD)에 CXL 메모리가 <strong>DRAM과 SSD 사이의 새로운 계층</strong>으로 추가된다. 기존 2계층(DRAM-SSD) 구조를 3계층(DDR-CXL-SSD) 구조로 확장하며, <strong>메모리-스토리지 격차(Memory-Storage Gap)</strong>를 완화한다.</p>

<h4>7.3 컴포저블 인프라와의 연결</h4>
<p>CXL 3.0의 패브릭 기능은 <strong>컴포저블 인프라(Composable Infrastructure)</strong> 개념을 실현한다. CPU, GPU, 메모리, 스토리지를 독립적으로 구성하고 워크로드에 따라 동적으로 할당하는 소프트웨어 정의 데이터센터(SDDC)의 핵심 기술이다.</p>

<h3>제8장 시험 출제 관점</h3>
<p><strong>기출 연계</strong>: CXL은 CA 영역의 최신 기술 토픽으로, &ldquo;차세대 인터커넥트 기술&rdquo;, &ldquo;서버 메모리 확장 기술&rdquo;, &ldquo;이기종 컴퓨팅 아키텍처&rdquo; 등의 키워드로 출제될 수 있다.</p>
<p><strong>답안 구성 전략</strong>:</p>
<ul>
<li>서론(15%): 서버 메모리 병목(용량·대역폭·활용률) 문제 제기 → CXL 등장</li>
<li>본론(75%): CXL 정의 + 프로토콜 계층도(필수) + 3대 프로토콜 비교표 + Type 1/2/3 비교 + CXL 3.0 신규 기능</li>
<li>결론(10%): NUMA 연결 + 컴포저블 인프라 전망 + 메모리 계층 변화</li>
</ul>

</div>
</div>
</div>

<div id="script" class="hidden">
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<div class="flex items-center gap-2 mb-2">
<span class="px-3 py-1 bg-amber-100 text-amber-800 rounded-full text-xs font-bold">🔒 멘토 전용</span>
<h2 class="text-xl font-bold text-gray-900">🎬 강의 스크립트</h2>
</div>
<div class="bg-amber-50 border border-amber-200 rounded-lg p-3 mb-6 text-sm text-amber-700">
이 탭은 멘토 전용입니다. URL에 <code class="bg-amber-100 px-1 rounded">?mentor=true</code> 파라미터를 추가하면 접근할 수 있습니다.
</div>
<div class="textbook-content">

<h4>🎬 [도입부 — 약 3분]</h4>
<p>안녕하세요, 여러분. 오늘은 CA(Computer Architecture) 영역의 최신 핫토픽인 <strong>CXL(Compute Express Link) 3.0</strong>을 다루겠습니다.</p>
<p>이 토픽이 왜 중요하냐면요, 기술사 시험에서 최신 기술 동향 문제가 나올 때 CXL이 출제 가능성이 아주 높거든요. &ldquo;서버 아키텍처의 메모리 병목을 해결하는 기술&rdquo;, &ldquo;차세대 인터커넥트 표준&rdquo;, &ldquo;이기종 컴퓨팅 아키텍처&rdquo; — 이런 키워드로 나올 수 있어요. 특히 AI 시대에 메모리 수요가 폭증하면서 CXL의 중요성이 더 올라가고 있거든요.</p>
<p>자, 먼저 왜 CXL이 필요한지부터 이해해봅시다. 요즘 서버에서 가장 큰 문제가 뭐냐면, <strong>메모리가 부족하다</strong>는 거예요. ChatGPT 같은 AI 모델 학습하려면 메모리가 수백 GB 필요하고, SAP HANA 같은 인메모리 데이터베이스는 TB 단위 메모리를 요구하잖아요. 그런데 서버에 메모리를 무한정 꽂을 수가 없어요. CPU 소켓에 DIMM 슬롯이 16~24개 정도밖에 없으니까, DDR5 기준으로 소켓당 최대 2~4TB가 물리적 한계예요. 그리고 Gartner 보고서에 따르면 데이터센터 서버 비용의 40~60%가 메모리 비용이래요. 이 숫자를 서론에 넣으면 문제의 심각성이 확 와닿거든요.</p>
<p>메모리 병목은 크게 세 가지예요. <span class="highlight">&ldquo;용대활&rdquo;</span>로 외우세요. 용량 병목, 대역폭 병목, 활용률 병목. 이 세 가지를 해결하기 위해 Intel이 2019년에 CXL을 만든 거예요.</p>

<h4>🎬 [핵심 설명 — 3대 프로토콜 (약 7분)]</h4>
<p>자, CXL의 핵심 구조로 들어갑시다. CXL은 <strong>PCIe 물리 계층 위에서 동작하는 3가지 프로토콜</strong>을 정의해요. <span class="highlight">&ldquo;아캐멤&rdquo;</span>으로 외우세요. CXL.io, CXL.cache, CXL.mem.</p>
<p>왜 PCIe 위에 만들었냐면, 기존 서버에 이미 PCIe 슬롯이 있잖아요? 완전히 새로운 하드웨어를 만드는 게 아니라, 기존 PCIe 인프라를 재활용하면서 그 위에 새로운 프로토콜을 올린 거예요. Flex Bus라는 물리 인터페이스가 이걸 자동으로 협상(Negotiation)하는 거예요.</p>
<p><strong>CXL.io</strong>는 기존 PCIe랑 거의 같아요. 장치를 인식하고, 설정하고, 관리하는 역할이에요.</p>
<p><strong>CXL.cache</strong>가 첫 번째 차별화 포인트예요. 이건 GPU나 FPGA 같은 가속기가 호스트 CPU의 메모리를 캐싱할 때 쓰는 프로토콜이에요. 기존 PCIe에서는 GPU가 CPU 메모리에 접근하려면 DMA로 데이터를 복사해야 했어요. 이게 μs 단위로 느렸거든요. CXL.cache를 쓰면 하드웨어 수준에서 캐시 일관성을 보장하면서 <strong>ns 단위</strong>로 접근할 수 있어요.</p>
<p><strong>CXL.mem</strong>이 가장 혁신적이고 시험에서 가장 중요한 프로토콜이에요. 이건 호스트 CPU가 CXL 장치에 달린 메모리를 <strong>마치 자기 로컬 메모리처럼</strong> 직접 접근할 수 있게 해주는 거예요. 일반적인 Load/Store 명령으로 접근해요. 답안에 &ldquo;로드/스토어 방식의 직접 접근&rdquo;이라는 표현을 꼭 쓰세요.</p>

<h4>🎬 [핵심 설명 — 장치 유형과 CXL 3.0 (약 5분)]</h4>
<p>CXL 장치는 세 가지 유형이 있어요. Type 1은 가속기(SmartNIC), Type 2는 GPU처럼 자체 메모리도 있는 가속기, Type 3는 <strong>메모리 확장 전용</strong> 장치예요.</p>
<p>여기서 가장 중요한 게 <strong>Type 3</strong>예요. 기존에는 CPU 소켓의 DIMM 슬롯에만 메모리를 꽂을 수 있었는데, Type 3 장치를 쓰면 PCIe 슬롯에도 메모리를 꽂을 수 있어요. SK hynix가 96GB CXL DRAM 모듈을 이미 양산하고 있어요.</p>
<p>CXL 3.0의 핵심 신규 기능은 <strong>패브릭 구성</strong>이에요. 여러 서버가 하나의 거대한 <strong>공유 메모리 풀</strong>을 사용할 수 있어요. 메모리 활용률이 50~60%에서 80%까지 올릴 수 있어요. 그리고 PCIe 6.0 물리 계층을 사용해서 대역폭이 2배로 늘어났어요.</p>
<p>Meta가 CXL Type 3 장치를 도입해서 AI 추론 서버의 메모리를 2배로 확장하고, 서버 대수를 20% 줄였어요.</p>

<h4>🎬 [답안 작성 팁 — 약 3분]</h4>
<p>서론에서는 메모리 병목의 3가지 유형(<span class="highlight">&ldquo;용대활&rdquo;</span>)을 간결하게 제시하세요. Gartner의 &ldquo;메모리 비용이 서버 비용의 40~60%&rdquo;라는 수치를 넣으면 문제의 심각성이 와닿아요.</p>
<p>본론의 핵심은 <strong>두 가지 도식</strong>이에요. 첫째, CXL 프로토콜 계층 구조도. 둘째, 3대 프로토콜 비교표. Type 1/2/3 장치 유형도 꼭 비교표로 정리하세요.</p>
<p>결론에서는 <strong>NUMA 아키텍처</strong>와의 연결, <strong>컴포저블 인프라</strong> 전망 두 가지를 연결하세요.</p>

<h4>🎬 [마무리 — 약 2분]</h4>
<p>3대 프로토콜 <span class="highlight">&ldquo;아캐멤&rdquo;</span>, 메모리 3대 병목 <span class="highlight">&ldquo;용대활&rdquo;</span>, CXL 3.0 핵심 기능 <span class="highlight">&ldquo;패다백글&rdquo;</span>. 이 세 개 두문자어가 뼈대예요.</p>
<p>숫자도 기억하세요. 메모리 비용이 서버 비용의 40~60%, 기존 PCIe DMA는 μs인데 CXL.cache는 ns 수준, CXL 3.0은 PCIe 6.0 64GT/s로 대역폭 2배, Meta는 서버 20% 절감, CXL 메모리 지연시간은 로컬 DDR의 1.5~2배.</p>
<p>이 토픽은 다른 CA/OS 토픽과 연결 고리가 많아요. NUMA 아키텍처, 메모리 계층 구조, 캐시 일관성, 데이터센터 아키텍처 등 여러 문제에 응용할 수 있습니다. 비교적 새로운 기술이라 다른 수험생들이 준비가 안 되어 있을 가능성이 높아서, 출제되면 확실히 차별화할 수 있는 토픽이에요.</p>
<p>다음 강의에서 뵙겠습니다. 화이팅하세요!</p>

</div>
</div>
</div>

            <div id="quiz" class="hidden">
<!-- AI 실전 퀴즈 영역 -->
            <div class="bg-indigo-50 rounded-xl p-6 border border-indigo-100 mb-8">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="font-bold text-indigo-900 text-lg flex items-center"><span class="mr-2">🧠</span> AI 실전 문제 생성</h3>
                    <button onclick="generateQuiz()" id="btn-quiz-gen" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-sm transition-colors flex items-center gap-2"><span>✨ 새로운 문제 생성</span></button>
                </div>
                <div id="quiz-loading" class="hidden py-8 text-center">
                    <div class="typing-indicator flex justify-center mb-2"><span></span><span></span><span></span></div>
                    <p class="text-indigo-600 text-sm">AI가 문제를 출제하고 있습니다...</p>
                </div>
                <div id="quiz-container" class="hidden space-y-4">
                    <div class="bg-white p-5 rounded-lg shadow-sm border border-indigo-100">
                        <div class="flex items-start gap-2 mb-4">
                            <span id="quiz-type-badge" class="bg-indigo-100 text-indigo-800 text-xs font-bold px-2 py-1 rounded whitespace-nowrap mt-1">객관식</span>
                            <p id="quiz-question" class="font-bold text-gray-800 text-lg"></p>
                        </div>
                        <div id="quiz-options" class="space-y-2"></div>
                        <div id="quiz-input-area" class="hidden mt-4">
                            <div class="flex gap-2">
                                <input type="text" id="quiz-answer-input" placeholder="정답을 입력하세요" class="flex-grow border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                <button onclick="checkShortAnswer()" id="btn-short-submit" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-bold">제출</button>
                            </div>
                        </div>
                    </div>
                    <div id="quiz-feedback" class="hidden bg-white p-5 rounded-lg border-l-4"></div>
                </div>
                <div id="quiz-placeholder" class="text-center py-8 text-gray-500 border-2 border-dashed border-indigo-200 rounded-lg">
                    <p>&#39;새로운 문제 생성&#39; 버튼을 눌러 실력을 점검해보세요.</p>
                </div>
            </div>



<!-- 암기 노트 1: 두문자어 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<h2 class="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2">📝 암기 노트 ① — 두문자어</h2>
<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
<div class="bg-indigo-50 rounded-lg p-4 border border-indigo-200">
<div class="font-bold text-indigo-800 text-lg mb-1">"아캐멤"</div>
<p class="text-indigo-700 text-sm">3대 프로토콜: CXL.<strong>io</strong>(아이오) + CXL.<strong>cache</strong>(캐시) + CXL.<strong>mem</strong>(메모리)</p>
</div>
<div class="bg-green-50 rounded-lg p-4 border border-green-200">
<div class="font-bold text-green-800 text-lg mb-1">"용대활"</div>
<p class="text-green-700 text-sm">메모리 3대 병목: <strong>용</strong>량 병목 + <strong>대</strong>역폭 병목 + <strong>활</strong>용률 병목</p>
</div>
<div class="bg-purple-50 rounded-lg p-4 border border-purple-200">
<div class="font-bold text-purple-800 text-lg mb-1">"패다백글"</div>
<p class="text-purple-700 text-sm">CXL 3.0 핵심 기능: <strong>패</strong>브릭 + <strong>다</strong>중레벨스위칭 + <strong>백</strong>인밸리데이트 + <strong>글</strong>로벌패브릭</p>
</div>
<div class="bg-amber-50 rounded-lg p-4 border border-amber-200">
<div class="font-bold text-amber-800 text-lg mb-1">"피로캐"</div>
<p class="text-amber-700 text-sm">Type 3 장치 특성: <strong>P</strong>CIe슬롯 + <strong>로</strong>드스토어 + <strong>캐</strong>시가능</p>
</div>
</div>
</div>

<!-- 암기 노트 2: 골격 답안 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<h2 class="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2">📝 암기 노트 ② — 골격 답안</h2>
<table class="w-full border-collapse text-sm">
<thead><tr class="bg-gray-50">
<th class="border border-gray-200 px-4 py-3 text-left font-semibold">구분</th>
<th class="border border-gray-200 px-4 py-3 text-left font-semibold">핵심 내용</th>
<th class="border border-gray-200 px-4 py-3 text-center font-semibold w-20">비중</th>
</tr></thead>
<tbody>
<tr><td class="border border-gray-200 px-4 py-3 font-medium bg-indigo-50">서론</td><td class="border border-gray-200 px-4 py-3">메모리 병목 3가지("용대활") + CXL 등장 배경</td><td class="border border-gray-200 px-4 py-3 text-center">15%</td></tr>
<tr><td class="border border-gray-200 px-4 py-3 font-medium bg-blue-50">본론 1</td><td class="border border-gray-200 px-4 py-3">CXL 정의 + 프로토콜 계층도 + 3대 프로토콜 비교표</td><td class="border border-gray-200 px-4 py-3 text-center">30%</td></tr>
<tr><td class="border border-gray-200 px-4 py-3 font-medium bg-green-50">본론 2</td><td class="border border-gray-200 px-4 py-3">장치 유형(Type 1/2/3) 비교 + CXL 3.0 신규 기능</td><td class="border border-gray-200 px-4 py-3 text-center">25%</td></tr>
<tr><td class="border border-gray-200 px-4 py-3 font-medium bg-purple-50">본론 3</td><td class="border border-gray-200 px-4 py-3">적용 사례(Meta, SK hynix) + NUMA/메모리 계층 연결</td><td class="border border-gray-200 px-4 py-3 text-center">20%</td></tr>
<tr><td class="border border-gray-200 px-4 py-3 font-medium bg-amber-50">결론</td><td class="border border-gray-200 px-4 py-3">컴포저블 인프라 + 메모리 계층 변화 전망</td><td class="border border-gray-200 px-4 py-3 text-center">10%</td></tr>
</tbody>
</table>
</div>

<!-- 암기 노트 3: 필수 도식 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<h2 class="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2">📝 암기 노트 ③ — 필수 도식 & 차별화</h2>
<div class="space-y-4 mb-6">
<div class="bg-slate-50 rounded-lg p-4 border">
<div class="font-semibold text-gray-800 mb-1">📊 도식 1: CXL 프로토콜 계층 구조도</div>
<p class="text-sm text-gray-600">3대 프로토콜 + 트랜잭션/링크 계층 + PCIe PHY의 스택 구조</p>
</div>
<div class="bg-slate-50 rounded-lg p-4 border">
<div class="font-semibold text-gray-800 mb-1">📊 도식 2: 3대 프로토콜 비교표</div>
<p class="text-sm text-gray-600">역할, 방향, 용도, PCIe 대비 장점 비교</p>
</div>
<div class="bg-slate-50 rounded-lg p-4 border">
<div class="font-semibold text-gray-800 mb-1">📊 도식 3: 장치 유형(Type 1/2/3) 프로토콜 매핑표</div>
<p class="text-sm text-gray-600">각 유형이 사용하는 프로토콜 조합</p>
</div>
</div>
<h3 class="font-bold text-gray-800 mb-3">💎 차별화 포인트</h3>
<div class="space-y-2">
<div class="flex gap-3 items-start"><span class="bg-indigo-100 text-indigo-700 rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold flex-shrink-0 mt-0.5">1</span><p class="text-sm text-gray-700">메모리 병목의 3가지 유형(용량/대역폭/활용률)을 구분하여 서론에 명시하면 문제 인식의 깊이를 보여줄 수 있다.</p></div>
<div class="flex gap-3 items-start"><span class="bg-indigo-100 text-indigo-700 rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold flex-shrink-0 mt-0.5">2</span><p class="text-sm text-gray-700">CXL.cache의 캐시 일관성 메커니즘이 기존 PCIe DMA 대비 어떤 이점이 있는지를 "μs → ns 수준 지연시간 감소"로 정량화하면 설득력이 높아진다.</p></div>
<div class="flex gap-3 items-start"><span class="bg-indigo-100 text-indigo-700 rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold flex-shrink-0 mt-0.5">3</span><p class="text-sm text-gray-700">NUMA 아키텍처와의 연결로 CXL 메모리가 OS에서 어떻게 관리되는지를 설명하면 실무적 이해를 어필할 수 있다.</p></div>
<div class="flex gap-3 items-start"><span class="bg-indigo-100 text-indigo-700 rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold flex-shrink-0 mt-0.5">4</span><p class="text-sm text-gray-700">Meta의 CXL 도입 사례(서버 20% 절감)로 실제 산업 적용을 증명하면 최신 동향 파악을 보여준다.</p></div>
</div>
</div>

<!-- 제2부 암기 요약 전체 -->
<div class="bg-white rounded-xl shadow-sm p-6 sm:p-8">
<h2 class="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2">📖 제2부 — 서술형 답안 암기 요약</h2>
<div class="textbook-content">
<p class="text-sm text-gray-500 italic mb-4">서술형 답안지 작성을 위한 핵심 암기 포인트</p>

<h3>1. 한 줄 정의</h3>
<table>
<thead><tr><th>토픽</th><th>한 줄 정의</th></tr></thead>
<tbody><tr><td><strong>CXL 3.0</strong></td><td>PCIe 물리 계층 위에 3대 프로토콜(io/cache/mem)을 정의하여, CPU-가속기-메모리 간 캐시 일관성을 보장하는 개방형 인터커넥트 표준으로, 3.0에서 패브릭 구성과 다중 레벨 스위칭을 지원한다</td></tr></tbody>
</table>

<h3>2. 핵심 키워드 맵</h3>
<p><strong>프로토콜 키워드</strong>: CXL.io / CXL.cache / CXL.mem / Flex Bus / PCIe 6.0</p>
<p><strong>장치 유형 키워드</strong>: Type 1(가속기) / Type 2(GPU+메모리) / Type 3(메모리 확장)</p>
<p><strong>CXL 3.0 키워드</strong>: 패브릭 / 다중 레벨 스위칭 / Back-Invalidate / 64GT/s / 4096포트</p>
<p><strong>연관 키워드</strong>: NUMA / 메모리 계층 / 컴포저블 인프라 / SDDC / 메모리 풀링</p>

<h3>3. 두문자어 암기법</h3>
<ul>
<li><strong>3대 프로토콜</strong>: <span class="highlight">"아캐멤"</span> (io-cache-mem) — "아이오, 캐시, 메모리"의 축약</li>
<li><strong>메모리 3대 병목</strong>: <span class="highlight">"용대활"</span> (용량 병목-대역폭 병목-활용률 병목)</li>
<li><strong>CXL 3.0 핵심 기능</strong>: <span class="highlight">"패다백글"</span> (패브릭-다중레벨스위칭-백인밸리데이트-글로벌패브릭)</li>
<li><strong>Type 3 장치 특성</strong>: <span class="highlight">"피로캐"</span> (PCIe슬롯-로드스토어-캐시가능) → 기존 한계를 극복하는 3가지</li>
</ul>

<h3>4. 골격 답안 구조</h3>
<p><strong>1교시형 — 단일 답안 구조</strong></p>
<table>
<thead><tr><th>구분</th><th>핵심 내용</th><th>분량 비중</th></tr></thead>
<tbody>
<tr><td><strong>서론</strong></td><td>메모리 병목 3가지("용대활") + CXL 등장 배경</td><td>15%</td></tr>
<tr><td><strong>본론 1</strong></td><td>CXL 정의 + 프로토콜 계층도 + 3대 프로토콜 비교표</td><td>30%</td></tr>
<tr><td><strong>본론 2</strong></td><td>장치 유형(Type 1/2/3) 비교 + CXL 3.0 신규 기능</td><td>25%</td></tr>
<tr><td><strong>본론 3</strong></td><td>적용 사례(Meta, SK hynix) + NUMA/메모리 계층 연결</td><td>20%</td></tr>
<tr><td><strong>결론</strong></td><td>컴포저블 인프라 + 메모리 계층 변화 전망</td><td>10%</td></tr>
</tbody>
</table>

<h3>5. 필수 도식</h3>
<p><strong>도식 1: CXL 프로토콜 계층 구조도</strong> — 3대 프로토콜 + 트랜잭션/링크 계층 + PCIe PHY의 스택 구조</p>
<p><strong>도식 2: 3대 프로토콜 비교표</strong> — 역할, 방향, 용도, PCIe 대비 장점 비교</p>
<p><strong>도식 3: 장치 유형(Type 1/2/3) 프로토콜 매핑표</strong> — 각 유형이 사용하는 프로토콜 조합</p>

<h3>6. 차별화 포인트</h3>
<ul>
<li>메모리 병목의 3가지 유형(용량/대역폭/활용률)을 구분하여 서론에 명시하면 문제 인식의 깊이를 보여줄 수 있다.</li>
<li>CXL.cache의 캐시 일관성 메커니즘이 기존 PCIe DMA 대비 어떤 이점이 있는지를 "μs → ns 수준 지연시간 감소"로 정량화하면 설득력이 높아진다.</li>
<li>NUMA 아키텍처와의 연결로 CXL 메모리가 OS에서 어떻게 관리되는지를 설명하면 실무적 이해를 어필할 수 있다.</li>
<li>Meta의 CXL 도입 사례(서버 20% 절감)로 실제 산업 적용을 증명하면 최신 동향 파악을 보여준다.</li>
</ul>
</div>
</div>
</div>

<button onclick="toggleChat()" class="fixed bottom-6 right-6 w-14 h-14 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 transition-all z-50 flex items-center justify-center text-2xl" title="AI 튜터">💬</button>
<div id="chat-sidebar" class="fixed top-0 right-0 w-80 sm:w-96 h-full bg-white shadow-2xl z-50 closed flex flex-col">
<div class="flex items-center justify-between p-4 border-b bg-indigo-600 text-white">
<h3 class="font-bold text-sm">🤖 AI 튜터 — CXL 3.0</h3>
<button onclick="toggleChat()" class="text-white hover:text-indigo-200 text-xl">&times;</button>
</div>
<div id="chat-messages" class="flex-1 overflow-y-auto p-4 flex flex-col gap-2" style="background:#fafafa">
<div class="chat-msg ai">안녕하세요! CXL 3.0에 대해 궁금한 점을 물어보세요. 😊</div>
</div>
<div class="p-3 border-t flex gap-2">
<input id="chat-input" type="text" placeholder="질문을 입력하세요..." class="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-indigo-400" onkeypress="if(event.key==='Enter')sendChat()">
<button onclick="sendChat()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-medium hover:bg-indigo-700">전송</button>
</div>
</div>
</div>

<div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
<div class="bg-white rounded-2xl shadow-xl max-w-md w-full p-6">
<div class="flex justify-between items-center mb-4">
<h3 class="text-lg font-bold text-gray-900">🔑 Gemini API 설정</h3>
<button onclick="toggleSettings()" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
</div>
<p class="text-sm text-gray-600 mb-4">AI 퀴즈 생성과 튜터 채팅을 사용하려면 Gemini API Key가 필요합니다.</p>
<input id="api-key-input" type="password" placeholder="Gemini API Key를 입력하세요" class="w-full px-4 py-3 border border-gray-300 rounded-lg text-sm mb-3 focus:outline-none focus:ring-2 focus:ring-indigo-400">
<div class="flex gap-2">
<button onclick="saveApiKey()" class="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-medium hover:bg-indigo-700">저장</button>
<button onclick="toggleSettings()" class="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg text-sm font-medium hover:bg-gray-200">취소</button>
</div>
<p class="text-xs text-gray-400 mt-3">* API Key는 브라우저 로컬 스토리지에 저장됩니다.</p>
</div>
</div>
</main>
<footer class="bg-white mt-12 py-8 border-t border-gray-200">
<div class="max-w-6xl mx-auto px-4 text-center">
<div class="flex flex-col md:flex-row justify-center items-center gap-2 md:gap-6 text-sm text-gray-600 mb-3 font-medium">
<div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-indigo-500"></span><span>박교익PE (132회 정보관리기술사, dr.code92@gmail.com)</span></div>
</div>
<p class="text-xs text-gray-400">Copyright &copy; KPC 정보관리기술사 ZIP-UP 심화반. All rights reserved.</p>
</div>
</footer>
<script>
var isMentorMode=new URLSearchParams(window.location.search).get('mentor')==='true';
if(isMentorMode){document.getElementById('nav-script').classList.remove('hidden');}
var sections=isMentorMode?['overview','protocols','evolution','textbook','script','quiz']:['overview','protocols','evolution','textbook','quiz'];
function navTo(id){document.querySelectorAll('.nav-item').forEach(function(el){el.classList.remove('active','text-indigo-600');});document.getElementById('nav-'+id).classList.add('active','text-indigo-600');sections.forEach(function(s){document.getElementById(s).classList.add('hidden');});document.getElementById(id).classList.remove('hidden');window.scrollTo({top:0,behavior:'smooth'});}

var protoDetails={
'io':{title:'CXL.io — I/O 프로토콜',colorClass:'border-gray-500 bg-gray-50',content:'<p class="text-gray-700 leading-relaxed mb-3">기존 <strong>PCIe 프로토콜과 동일한 기능</strong>을 수행합니다. 장치 열거(Enumeration), 구성 공간 접근, 인터럽트(MSI/MSI-X), DMA 등을 처리합니다.</p><p class="text-gray-700 leading-relaxed mb-3"><strong>방향</strong>: 호스트 → 디바이스</p><p class="text-gray-700 leading-relaxed mb-3"><strong>설계 원칙</strong>: PCIe와의 하위 호환성(Backward Compatibility)을 유지하여 기존 소프트웨어 스택(OS 드라이버, BIOS)을 최소 수정으로 CXL 도입 가능.</p><div class="bg-gray-100 rounded-lg p-3"><p class="text-gray-700 text-sm">CXL 장치가 시스템에 연결되면 먼저 CXL.io로 장치를 인식한 후, CXL.cache/CXL.mem 프로토콜이 활성화됩니다.</p></div>'},
'cache':{title:'CXL.cache — 캐시 프로토콜',colorClass:'border-blue-500 bg-blue-50',content:'<p class="text-gray-700 leading-relaxed mb-3"><strong>디바이스(가속기)가 호스트 CPU 메모리를 캐싱</strong>할 때 사용하는 프로토콜입니다. GPU/FPGA가 호스트 메모리 데이터를 로컬 캐시에 저장하면서 <strong>캐시 일관성(Coherency)</strong>을 유지합니다.</p><p class="text-gray-700 leading-relaxed mb-3"><strong>방향</strong>: 디바이스 → 호스트</p><table class="w-full border-collapse text-sm my-3"><tr><td class="border px-3 py-2 font-medium bg-blue-50">스누프(Snoop)</td><td class="border px-3 py-2">호스트가 디바이스 캐시 유효성을 확인</td></tr><tr><td class="border px-3 py-2 font-medium bg-blue-50">데이터 전달</td><td class="border px-3 py-2">캐시 라인 단위(64B)로 전달</td></tr><tr><td class="border px-3 py-2 font-medium bg-blue-50">소유권 변경</td><td class="border px-3 py-2">MESI 프로토콜 확장 (M/S/I 상태 관리)</td></tr></table><div class="bg-blue-100 rounded-lg p-3"><p class="text-blue-800 text-sm font-medium">⚡ 기존 PCIe DMA(μs 단위) → CXL.cache(ns 단위)로 지연시간 대폭 감소</p></div>'},
'mem':{title:'CXL.mem — 메모리 프로토콜',colorClass:'border-indigo-500 bg-indigo-50',content:'<p class="text-gray-700 leading-relaxed mb-3"><strong>호스트 CPU가 CXL 장치의 메모리를 직접 접근</strong>하기 위한 프로토콜입니다. 호스트의 물리 주소 공간에 CXL 메모리를 매핑하여 <strong>Load/Store 명령으로 직접 접근</strong>합니다.</p><p class="text-gray-700 leading-relaxed mb-3"><strong>방향</strong>: 호스트 → 디바이스</p><table class="w-full border-collapse text-sm my-3"><tr><th class="border px-3 py-2 bg-gray-100">비교</th><th class="border px-3 py-2 bg-gray-100">기존 PCIe (MMIO)</th><th class="border px-3 py-2 bg-gray-100">CXL.mem</th></tr><tr><td class="border px-3 py-2 font-medium">지연시간</td><td class="border px-3 py-2">μs 단위</td><td class="border px-3 py-2 text-indigo-700 font-medium">수십~수백 ns</td></tr><tr><td class="border px-3 py-2 font-medium">캐싱</td><td class="border px-3 py-2">비캐시(Uncacheable)</td><td class="border px-3 py-2 text-indigo-700 font-medium">캐시 가능</td></tr><tr><td class="border px-3 py-2 font-medium">CPU 명령</td><td class="border px-3 py-2">특수 I/O 명령</td><td class="border px-3 py-2 text-indigo-700 font-medium">일반 Load/Store</td></tr></table><div class="bg-indigo-100 rounded-lg p-3"><p class="text-indigo-800 text-sm font-medium">🔑 CXL의 가장 혁신적 프로토콜: 소프트웨어 관점에서 CXL 메모리가 추가 DRAM처럼 보임</p></div>'}
};
function updateProtoDetail(key){document.querySelectorAll('.tech-block').forEach(function(el){el.classList.remove('selected','ring-2','ring-indigo-500','bg-indigo-50','border-indigo-500');});var el=document.getElementById('block-'+key);if(el){el.classList.add('selected','ring-2','ring-indigo-500','bg-indigo-50','border-indigo-500');}var d=protoDetails[key];document.getElementById('proto-detail-content').innerHTML='<div class="'+d.colorClass+' border-l-4 rounded-r-lg p-5 animate-fade-in"><h4 class="text-lg font-bold text-gray-900 mb-3">'+d.title+'</h4>'+d.content+'</div>';}

function toggleStrategy(el){var d=el.querySelector('.strategy-detail');var s=el.querySelector('.strategy-summary');if(d.classList.contains('hidden')){document.querySelectorAll('.strategy-detail').forEach(function(x){x.classList.add('hidden');});document.querySelectorAll('.strategy-summary').forEach(function(x){x.classList.remove('hidden');});d.classList.remove('hidden');s.classList.add('hidden');}else{d.classList.add('hidden');s.classList.remove('hidden');}}

function getApiKey(){var k=localStorage.getItem('gemini_api_key');if(!k){k=new URLSearchParams(window.location.search).get('key');}return k;}
function saveApiKey(){var k=document.getElementById('api-key-input').value.trim();if(k){localStorage.setItem('gemini_api_key',k);toggleSettings();alert('API Key가 저장되었습니다!');}else{alert('API Key를 입력해주세요.');}}
function toggleSettings(){var m=document.getElementById('settings-modal');m.classList.toggle('hidden');var k=localStorage.getItem('gemini_api_key');if(k){document.getElementById('api-key-input').value=k;}}
function toggleChat(){var sb=document.getElementById('chat-sidebar');sb.classList.toggle('open');sb.classList.toggle('closed');}
async function sendChat(){var input=document.getElementById('chat-input');var msg=input.value.trim();if(!msg)return;input.value='';var box=document.getElementById('chat-messages');box.innerHTML+='<div class="chat-msg user">'+msg+'</div>';box.innerHTML+='<div id="typing" class="chat-msg ai"><div class="typing-indicator"><span></span><span></span><span></span></div></div>';box.scrollTop=box.scrollHeight;var key=getApiKey();if(!key){document.getElementById('typing').remove();box.innerHTML+='<div class="chat-msg ai">⚠️ API Key가 설정되지 않았습니다. 🔑 API 버튼을 클릭하여 설정해주세요.</div>';box.scrollTop=box.scrollHeight;return;}try{var r=await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key='+key,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({contents:[{role:'user',parts:[{text:'당신은 정보관리기술사 시험 멘토입니다. "CXL(Compute Express Link) 3.0" 관련 질문에 전문적이고 명쾌하게 답변해주세요. 300자 이내로 핵심만 요약.\n\n질문: '+msg}]}]})});var d=await r.json();document.getElementById('typing').remove();var answer=d.candidates[0].content.parts[0].text;if(typeof marked!=='undefined'){answer=marked.parse(answer);}box.innerHTML+='<div class="chat-msg ai">'+answer+'</div>';}catch(e){document.getElementById('typing').remove();box.innerHTML+='<div class="chat-msg ai">⚠️ 오류: '+e.message+'</div>';}box.scrollTop=box.scrollHeight;}

    (function(){var p=new URLSearchParams(window.location.search);var k=p.get('key');if(k){localStorage.setItem('gemini_api_key',k);}})();

    // ── 퀴즈 ──
    // Bridge: connect quiz JS to existing API key management
    var geminiKey = (typeof getApiKey === 'function') ? (getApiKey() || '') : '';

    var quizTypeHistory = [];
    var currentQuizData = null;
    var quizTopics=[
{category:'서버 메모리 병목과 CXL 등장',keywords:'메모리 병목, 용량 병목, 대역폭 병목, 활용률 병목, Gartner, DDR5, DIMM, PCIe'},
{category:'CXL 3대 프로토콜',keywords:'CXL.io, CXL.cache, CXL.mem, 캐시 일관성, Load/Store, Flex Bus, 스누프'},
{category:'CXL 장치 유형',keywords:'Type 1, Type 2, Type 3, SmartNIC, GPU, FPGA, 메모리 확장 장치'},
{category:'CXL 버전별 발전',keywords:'CXL 1.0, CXL 2.0, CXL 3.0, PCIe 5.0, PCIe 6.0, 메모리 풀링, 패브릭'},
{category:'CXL 3.0 핵심 기능',keywords:'패브릭 구성, 다중 레벨 스위칭, Back-Invalidate, 64GT/s, 4096포트, GFD'},
{category:'연관 이론과 적용',keywords:'NUMA, 메모리 계층, 컴포저블 인프라, SDDC, Tiered Memory, HDM, Meta, SK hynix'}
];
    async function generateQuiz() {
        geminiKey = (typeof getApiKey === 'function') ? (getApiKey() || '') : geminiKey;
        if (!geminiKey) { alert('API Key를 먼저 설정해주세요.'); toggleSettings(); return; }
        var btn = document.getElementById('btn-quiz-gen');
        btn.disabled = true; btn.innerHTML = '<span>생성 중...</span>';
        document.getElementById('quiz-placeholder').classList.add('hidden');
        document.getElementById('quiz-container').classList.add('hidden');
        document.getElementById('quiz-loading').classList.remove('hidden');
        var isMC;
        var recent = quizTypeHistory.slice(-2);
        if (recent.length >= 2 && recent[0] === recent[1]) { isMC = !recent[1]; }
        else { isMC = Math.random() > 0.5; }
        quizTypeHistory.push(isMC);
        var selected = quizTopics[Math.floor(Math.random() * quizTopics.length)];
        var quizType = isMC ? '객관식 (4지선다)' : '단답형';
        var format = isMC
            ? '{"question":"문제","options":["A","B","C","D"],"correctIndex":0,"explanation":"해설"}'
            : '{"question":"문제","correctAnswer":"정답","explanation":"해설"}';
        var prompt = "다음 카테고리에 대한 " + quizType + " 퀴즈 1문제를 만드세요.\n"
            + "카테고리: " + selected.category + "\n"
            + "관련 키워드: " + selected.keywords + "\n"
            + "규칙: 반드시 위 카테고리와 키워드에 직접 관련된 문제를 출제하세요.\n"
            + "JSON 형식으로 응답: " + format;
        try {
            var r = await fetch(
                'https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key=' + geminiKey,
                { method:'POST', headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ contents:[{parts:[{text:prompt}]}], generationConfig:{responseMimeType:"application/json"} })
                }
            );
            var d = await r.json();
            var t = d.candidates[0].content.parts[0].text;
            t = t.replace(/```json\s*/gi,"").replace(/```\s*/g,"").trim();
            var depth=0, start=-1, end=-1;
            for (var i=0;i<t.length;i++) {
                if (t[i]==='{') { if(depth===0) start=i; depth++; }
                else if (t[i]==='}') { depth--; if(depth===0 && start!==-1) { end=i; break; } }
            }
            if (start===-1||end===-1) throw new Error("No JSON found");
            t = t.substring(start, end+1);
            t = t.replace(/[\x00-\x1F\x7F]/g, function(c) { return c==='\n'||c==='\r'||c==='\t' ? ' ' : ''; });
            currentQuizData = JSON.parse(t);
            renderQuiz(isMC);
        } catch(e) {
            document.getElementById('quiz-loading').classList.add('hidden');
            document.getElementById('quiz-placeholder').classList.remove('hidden');
            document.getElementById('quiz-placeholder').innerHTML = '<p class="text-red-500">퀴즈 생성 오류: ' + e.message + '</p>';
        }
        btn.disabled = false; btn.innerHTML = '<span>✨ 새로운 문제 생성</span>';
    }
    function renderQuiz(isMC) {
        document.getElementById('quiz-loading').classList.add('hidden');
        document.getElementById('quiz-feedback').classList.add('hidden');
        document.getElementById('quiz-container').classList.remove('hidden');
        document.getElementById('quiz-type-badge').textContent = isMC ? '객관식' : '단답형';
        document.getElementById('quiz-question').textContent = currentQuizData.question;
        var optDiv = document.getElementById('quiz-options');
        var inputDiv = document.getElementById('quiz-input-area');
        if (isMC) {
            optDiv.classList.remove('hidden');
            inputDiv.classList.add('hidden');
            var h = '';
            var letters = ['A','B','C','D'];
            currentQuizData.options.forEach(function(opt, i) {
                h += '<button onclick="checkMultipleChoice(' + i + ', this)" class="w-full text-left p-4 rounded-lg border border-gray-200 hover:bg-indigo-50 hover:border-indigo-300 transition-all mb-2 flex items-center group">'
                    + '<span class="w-8 h-8 rounded-full bg-gray-100 group-hover:bg-indigo-100 flex items-center justify-center text-sm font-bold text-gray-500 group-hover:text-indigo-600 mr-3 flex-shrink-0">' + letters[i] + '</span>'
                    + '<span class="text-sm text-gray-700">' + opt + '</span></button>';
            });
            optDiv.innerHTML = h;
        } else {
            optDiv.classList.add('hidden');
            inputDiv.classList.remove('hidden');
            document.getElementById('quiz-answer-input').value = '';
            document.getElementById('quiz-answer-input').focus();
        }
    }
    function checkMultipleChoice(idx, btnEl) {
        var correct = idx === currentQuizData.correctIndex;
        document.querySelectorAll('#quiz-options button').forEach(function(b, i) {
            b.disabled = true;
            if (i === currentQuizData.correctIndex) { b.classList.add('bg-green-50','border-green-400'); b.querySelector('span:first-child').classList.add('bg-green-100','text-green-700'); }
            else if (i === idx && !correct) { b.classList.add('bg-red-50','border-red-400'); b.querySelector('span:first-child').classList.add('bg-red-100','text-red-700'); }
        });
        showQuizFeedback(correct, currentQuizData.options[currentQuizData.correctIndex], currentQuizData.explanation);
    }
    async function checkShortAnswer() {
        geminiKey = (typeof getApiKey === 'function') ? (getApiKey() || '') : geminiKey;
        var ans = document.getElementById('quiz-answer-input').value.trim();
        if (!ans) { alert('답을 입력해주세요.'); return; }
        var btn = document.getElementById('btn-short-submit');
        btn.disabled = true; btn.textContent = '채점 중...';
        try {
            var gradingPrompt = "당신은 정보관리기술사 시험 채점관입니다. 아래 문제에 대해 사용자의 답안이 정답으로 인정될 수 있는지 판정하세요.\n\n"
                + "문제: " + currentQuizData.question + "\n"
                + "모범 정답: " + currentQuizData.correctAnswer + "\n"
                + "사용자 답안: " + ans + "\n\n"
                + "판정 기준:\n- 핵심 의미가 동일하면 정답\n- 약어/풀네임 모두 인정\n- 영어/한글 혼용 인정\n- 띄어쓰기/조사 차이는 무시\n- 의미가 명확히 다르면 오답\n\n"
                + "Output JSON: {\"correct\":true/false,\"reason\":\"판정 이유\"}";
            var r = await fetch(
                'https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent?key=' + geminiKey,
                { method:'POST', headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ contents:[{parts:[{text:gradingPrompt}]}], generationConfig:{responseMimeType:"application/json"} })
                }
            );
            var d = await r.json();
            var gt = d.candidates[0].content.parts[0].text;
            gt = gt.replace(/```json\s*/gi,"").replace(/```\s*/g,"").trim();
            var gd=0,gs=-1,ge=-1;
            for(var i=0;i<gt.length;i++){if(gt[i]==='{'){if(gd===0)gs=i;gd++;}else if(gt[i]==='}'){gd--;if(gd===0&&gs!==-1){ge=i;break;}}}
            if(gs===-1||ge===-1) throw new Error("No JSON");
            gt=gt.substring(gs,ge+1);
            gt=gt.replace(/[\x00-\x1F\x7F]/g,function(c){return c==='\n'||c==='\r'||c==='\t'?' ':'';});
            var result = JSON.parse(gt);
            showQuizFeedback(result.correct, currentQuizData.correctAnswer, currentQuizData.explanation + (result.reason ? ' (AI: ' + result.reason + ')' : ''));
        } catch(e) {
            var normalize = function(s){return s.replace(/\s/g,'').toLowerCase();};
            var correct = normalize(currentQuizData.correctAnswer).includes(normalize(ans)) || normalize(ans).includes(normalize(currentQuizData.correctAnswer));
            showQuizFeedback(correct, currentQuizData.correctAnswer, currentQuizData.explanation + ' (로컬 채점)');
        }
        btn.disabled = false; btn.textContent = '제출';
    }
    function showQuizFeedback(correct, answer, explanation) {
        var fb = document.getElementById('quiz-feedback');
        fb.classList.remove('hidden','border-green-500','bg-green-50','border-red-500','bg-red-50');
        if (correct) {
            fb.classList.add('border-green-500','bg-green-50');
            fb.innerHTML = '<p class="font-bold text-green-700 mb-1">✅ 정답입니다!</p><p class="text-sm text-green-600">' + explanation + '</p>';
        } else {
            fb.classList.add('border-red-500','bg-red-50');
            fb.innerHTML = '<p class="font-bold text-red-700 mb-1">❌ 오답입니다.</p><p class="text-sm text-red-700 mb-1">정답: ' + answer + '</p><p class="text-sm text-red-600">' + explanation + '</p>';
        }
    }
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && document.getElementById('quiz-answer-input') === document.activeElement) { checkShortAnswer(); }
    });
</script>
</body></html>
